{"question_type": "code_audit", "title": "Solidity Re-entrancy (basic vault)", "instructions": "Identify the vulnerability and provide fixed code.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amount， \"Insufficient balance\");\n        (bool success， ) = msg.sender.call{value: amount}(\"\");\n        require(success， \"Transfer failed\");\n        balances[msg.sender] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "reentrant"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw_workflow", "test_reentrancy_attack_prevention"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureBank is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        require(balances[msg.sender] >= amount， \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool success， ) = msg.sender.call{value: amount}(\"\");\n        require(success， \"Transfer failed\");\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "ERC-777 / ERC-20 Callback Re-entrancy", "instructions": "Locate the vulnerability in the vault and supply a patched version.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract VulnerableVault is IERC777Recipient {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    // ERC-777 hook fires before balance update → re-entrancy window\n    function tokensReceived(\n        address， address from， address， uint256 amount，\n        bytes calldata， bytes calldata\n    ) external override {\n        deposits[from] += amount;\n    }\n\n    function withdraw(uint256 amt) external {\n        require(deposits[msg.sender] >= amt， \"not enough\");\n        token.transfer(msg.sender， amt);     // external call first ⇒ re-entrancy\n        deposits[msg.sender] -= amt;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "callback"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw", "test_callback_reentrancy"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureVault is IERC777Recipient， ReentrancyGuard {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    function tokensReceived(\n        address， address from， address， uint256 amount，\n        bytes calldata， bytes calldata\n    ) external override {\n        deposits[from] += amount;           // state change first\n    }\n\n    function withdraw(uint256 amt) external nonReentrant {\n        require(deposits[msg.sender] >= amt， \"not enough\");\n        deposits[msg.sender] -= amt;        // Effects\n        require(token.transfer(msg.sender， amt)， \"transfer failed\"); // Interaction\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "Predictable On-Chain Randomness", "instructions": "Explain why the randomness is predictable and provide a secure alternative.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract PredictableLottery {\n    function draw() external view returns (uint256) {\n        return uint256(\n            keccak256(abi.encodePacked(blockhash(block.number - 1)， block.timestamp))\n        ) % 100; // miner-controlled input\n    }\n}", "vulnerability_type": "predictable_randomness", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["predictable", "randomness"]}, {"criterion": "implements_vrf_or_commit_reveal", "points": 3, "check_function": "check_secure_randomness"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_unpredictable_draw"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract VRFLottery is VRFConsumerBase { /* VRF wiring omitted */ }", "total_possible": 6}
{"question_type": "code_audit", "title": "Rent-Exempt Bypass (Solana)", "instructions": "Demonstrate how a rent exemption bypass can be exploited in Solana account management and propose a solution. Your solution should include a code fix and the implementation of a validation check to prevent further exploitation of this vulnerability.", "contract_code": "// Attacker tops up lamports to appear rent-exempt， then withdraws in the same slot， bypassing the rent exemption check.", "vulnerability_type": "rent_exemption_spoof", "scoring_criteria": [{"criterion": "Identifies the Vulnerability Type", "points": 2, "keywords": ["rent", "exempt", "spoof"], "description": "The student must correctly identify the rent exemption spoof vulnerability in the provided contract code， demonstrating understanding of how attackers manipulate rent exemption status."}, {"criterion": "Adds Post-Instruction Check", "points": 3, "check_function": "check_rent_after_ops", "description": "The student must implement a validation check after critical operations to ensure that the account still meets the rent exemption criteria. This is done by calling sysvar::rent::check_reserve(&account) after every transfer."}, {"criterion": "Fix Implementation", "points": 4, "description": "The student should provide a code fix that prevents rent exemption spoofing. The solution must include a reliable check for rent exemption after the transaction and before any withdrawals can happen."}], "automated_tests": ["test_rent_exempt_validation", "test_account_rent_check_post_transaction"], "reference_solution": "// Code Fix: After all transfers， validate the rent exemption status by invoking sysvar::rent::check_reserve(&account). If the account does not meet the rent exemption criteria， the transaction should fail.\n\nfn check_rent_after_ops(account: &Account) -> Result<()， &'static str> {\n  if !sysvar::rent::check_reserve(account) {\n    return Err(\"Account does not meet rent exemption criteria\");\n  }\n  Ok(())\n}", "total_possible": 9}
{"question_type": "code_audit", "title": "CosmWasm BankMsg Unlimited Send", "instructions": "Spot the unbounded token forward and cap the loss.", "contract_code": "// CosmWasm 1.3\npub fn execute_forward(\n    _deps: DepsMut，\n    _info: MessageInfo，\n    to: String，\n    amount: Coin，\n) -> Result<Response， StdError> {\n    let msg = cosmwasm_std::BankMsg::Send {\n        to_address: to，\n        amount: vec![amount]，\n    }; // no upper limit or ACL\n    Ok(Response::new().add_message(msg))\n}", "vulnerability_type": "unbounded_transfer", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["unlimited", "drain"]}, {"criterion": "adds_amount_cap_or_acl", "points": 3, "check_function": "check_amount_limit"}], "automated_tests": ["test_max_transfer_cap"], "reference_solution": "Assert amount ≤ MAX_CAP and require sender is whitelisted before forwarding.", "total_possible": 5}
{"question_type": "code_audit", "title": "IBC Light-Client Verification Flaw", "instructions": "Describe the proof-height bug and harden the check.", "contract_code": "// Cosmos SDK 0.47\nif !client.verify_membership(store， proof， proof_height， ...) {\n    // should compare with trusted_height but does not\n}", "vulnerability_type": "light_client_height_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["proof-height"]}, {"criterion": "enforces_monotonic_height", "points": 3, "check_function": "check_height_validation"}], "automated_tests": ["test_forged_packet_blocked"], "reference_solution": "Require proof_height ≥ consensus_state.latest_height and ≤ trusted_height; prune expired consensus states.", "total_possible": 5}
{"question_type": "code_audit", "title": "MPC Threshold Signature Bypass", "instructions": "Analyse how inconsistent curve parameters break the threshold guarantee and lock them down.", "contract_code": "// Rust (simplified)\nstruct Share { curve_id: Option<u8>， r: Scalar， s: Scalar }\n// Coordinator never verifies that all shares use the same curve_id", "vulnerability_type": "threshold_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["threshold", "bypass"]}, {"criterion": "binds_curve_params", "points": 3, "check_function": "check_curve_id"}], "automated_tests": ["test_threshold_enforcement"], "reference_solution": "Add curve domain separator to every share transcript and reject aggregation if any curve_id mismatches.", "total_possible": 5}
{"question_type": "code_audit", "title": "Solidity Unrestricted Self-Destruct", "instructions": "Show how anyone can destroy the contract and fix the access control.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract BoomBox {\n    function boom(address payable receiver) external {\n        selfdestruct(receiver); // 🔥 unrestricted\n    }\n    receive() external payable {}\n}", "vulnerability_type": "unrestricted_selfdestruct", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["selfdestruct", "access"]}, {"criterion": "locks_down_or_removes_selfdestruct", "points": 3, "check_function": "check_only_owner"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_selfdestruct_protection"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract SafeBox {\n    address public immutable owner = msg.sender;\n    modifier onlyOwner { require(msg.sender == owner， \"not owner\"); _; }\n\n    function destroy(address payable receiver) external onlyOwner {\n        selfdestruct(receiver);\n    }\n    receive() external payable {}\n}", "total_possible": 6}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract for security vulnerabilities related to the use of delegatecall. Explain the risks associated with arbitrary delegatecall and propose a secure solution that restricts the callee to a trusted implementation. Consider using established patterns and libraries to enhance security.", "factors_to_consider": ["The risk of arbitrary delegatecall allowing unauthorized code execution", "The importance of restricting the implementation address to a trusted source", "The use of established proxy patterns and libraries like OpenZeppelin", "Gas efficiency and execution cost implications", "Potential edge cases and attack vectors specific to delegatecall"], "keywords": ["delegatecall", "proxy pattern", "OpenZeppelin", "trusted implementation", "smart contract security", "Solidity"], "expected_insights": ["Understanding of delegatecall risks and how they can lead to unauthorized state changes", "Knowledge of how to restrict the implementation address to prevent arbitrary delegatecall", "Familiarity with using OpenZeppelin's proxy contracts to enhance security", "Ability to identify and mitigate potential attack vectors in smart contract design"], "scoring_criteria": [{"criterion": "identifies_delegatecall_issue", "points": 2, "key_points": ["Recognizes the security risk of arbitrary delegatecall", "Explains potential consequences of the vulnerability"]}, {"criterion": "restricts_implementation_address", "points": 3, "key_points": ["Proposes a method to restrict the implementation address to a trusted source", "Demonstrates understanding of access control mechanisms"]}, {"criterion": "uses_secure_proxy_pattern", "points": 2, "key_points": ["Recommends using OpenZeppelin's proxy pattern", "Explains the benefits of using established libraries"]}], "total_possible": 7, "id": 9, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// A contract that can be used as a library for the main contract.\ncontract LibraryContract {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n\n// The main contract that uses delegatecall to call the library.\n// This contract is vulnerable because the library address can be changed by anyone.\ncontract VulnerableProxy {\n    address public implementation;\n    address public owner;\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n        owner = msg.sender;\n    }\n\n    // The attacker can change the implementation address to a malicious contract.\n    function setImplementation(address _newImplementation) public {\n        implementation = _newImplementation;\n    }\n\n    // The fallback function that delegates calls to the implementation contract.\n    fallback() external payable {\n        (bool success， bytes memory data) = implementation.delegatecall(msg.data);\n        require(success， \"Delegatecall failed\");\n    }\n}\n"}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify vulnerabilities related to ECDSA signature malleability. Demonstrate how an attacker could exploit the 's' value malleability to reuse permits. Implement a solution that enforces EIP-2 compliance by ensuring the 's' value is in the lower half of the secp256k1 curve and properly manages nonces to prevent replay attacks. Provide a detailed explanation of your approach and the security implications.", "factors_to_consider": ["ECDSA signature malleability", "EIP-2 compliance for 's' value", "Nonce management to prevent replay attacks", "Security implications of signature reuse", "Compatibility with existing ERC20 standards"], "keywords": ["ECDSA", "signature malleability", "EIP-2", "nonce management", "replay attack", "Solidity", "ERC20"], "expected_insights": ["Understanding of ECDSA signature structure and vulnerabilities", "Knowledge of EIP-2 and its importance in preventing malleability", "Ability to implement nonce management to enhance security", "Insight into how signature malleability can be exploited in smart contracts", "Technical proficiency in Solidity for implementing secure contracts"], "scoring_criteria": [{"criterion": "Identifies signature malleability vulnerability", "points": 2, "key_points": ["Correctly identifies the 's' value malleability issue", "Explains potential exploits using signature reuse"]}, {"criterion": "Implements EIP-2 compliance", "points": 3, "key_points": ["Ensures 's' value is in the lower half of the curve", "Explains the significance of EIP-2 compliance"]}, {"criterion": "Manages nonces effectively", "points": 2, "key_points": ["Implements nonce incrementation on successful permit", "Prevents replay attacks through nonce checks"]}, {"criterion": "Code compiles and functions correctly", "points": 1, "key_points": ["Code compiles without errors", "Passes provided automated tests"]}], "total_possible": 8, "id": 10, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// This contract is vulnerable to ECDSA signature malleability.\n// An attacker can submit a valid signature with a different `s` value.\ncontract VulnerableSignatureValidator {\n    address public signer;\n\n    constructor(address _signer) {\n        signer = _signer;\n    }\n\n    // This function is vulnerable because it does not check for a unique `s` value.\n    function isValidSignature(bytes32 message， bytes memory signature) public view returns (bool) {\n        return ECDSA.recover(message， signature) == signer;\n    }\n\n    // An attacker can use this function to replay a valid signature with a modified `s` value.\n    function execute(bytes32 message， bytes memory signature) public {\n        require(isValidSignature(message， signature)， \"Invalid signature\");\n        // Execute some action...\n    }\n}\n"}
{"question_type": "code_audit", "title": "Cairo Dictionary Key Collision", "instructions": "Identify the dictionary seed collision and propose deterministic namespacing.", "contract_code": "# Cairo 1.1\n@storage_var\ndef balances(key: felt) -> felt:\n    pass\n\n@external\ndef deposit{syscall_ptr: felt*， pedersen_ptr: HashBuiltin*， range_check_ptr}(user: felt， amount: felt):\n    balances.write(user， balances.read(user) + amount)\n\n# Multiple contracts deploying this code will share the same storage path for identical keys", "vulnerability_type": "storage_key_collision", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["collision", "storage", "dictionary"]}, {"criterion": "adds_contract_address_to_seed", "points": 3, "check_function": "check_unique_seed"}], "automated_tests": ["test_no_storage_overlap"], "reference_solution": "@storage_var\ndef balances(contract_address: felt， key: felt) -> felt: pass  # include deployer address", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify potential vulnerabilities related to gas stipend limitations when using transfer(). Refactor the contract to use a safer ETH transfer pattern， such as call()， ensuring the contract remains secure and functional. Provide a detailed explanation of the changes made and why they address the identified issues.", "factors_to_consider": ["Impact of EIP-1884 on gas costs", "Differences between transfer()， send()， and call()", "Security implications of using call()", "Ensuring reentrancy safety"], "keywords": ["EIP-1884", "gas stipend", "transfer()", "call()", "reentrancy"], "expected_insights": ["Understanding of gas stipend limitations post-EIP-1884", "Ability to refactor code to use call() safely", "Knowledge of reentrancy vulnerabilities and prevention techniques"], "scoring_criteria": [{"criterion": "Identifies gas stipend vulnerability", "points": 2, "key_points": ["Mentions EIP-1884 impact", "Explains why transfer() can fail"]}, {"criterion": "Refactors to safe ETH transfer pattern", "points": 3, "key_points": ["Uses call() with proper checks", "Ensures reentrancy safety"]}, {"criterion": "Code compiles successfully", "points": 1, "key_points": ["No syntax errors", "Compiles with Solidity 0.8.22"]}], "total_possible": 6, "id": 12}
{"question_type": "code_audit", "title": "NEAR Promise Callback Re-entrancy", "instructions": "Demonstrate the re-entrancy window in the callback and defend against it.", "contract_code": "// Rust – NEAR\n#[near_bindgen]\nimpl Contract {\n    #[payable]\n    pub fn lock(&mut self) {\n        let amount = env::attached_deposit();\n        Promise::new(self.vault.clone()).transfer(amount).then(\n            Promise::new(env::current_account_id()).function_call(\n                \"release\".to_string()，\n                vec![]， 0， Gas(50_000_000_000_000)\n            )\n        ); // state not updated until after the external transfer\n    }\n\n    pub fn release(&mut self) {\n        self.unlocked = true; // attacker re-enters before lock state set\n    }\n}", "vulnerability_type": "promise_reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["promise", "reentrancy"]}, {"criterion": "moves_state_update_before_promise", "points": 3, "check_function": "check_effects_first"}], "automated_tests": ["test_promise_reentrancy_guard"], "reference_solution": "Set self.locked = true before issuing the Promise and require(!locked) in entry functions.", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Identify the ownership issue in this token transfer contract and provide fixed code that properly handles mutable borrowing", "contract_code": "struct Token {\n    balances: std::collections::HashMap<String， u64>，\n}\n\nimpl Token {\n    fn transfer(&self， from: &str， to: &str， amount: u64) -> Result<()， &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()， from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow", "points": 2, "keywords": ["immutable", "mutable", "self", "borrow"]}, {"criterion": "fixes_method_signature", "points": 3, "check_function": "check_mutable_self_correction"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_token_transfer"}], "automated_tests": ["test_token_transfer", "test_insufficient_balance"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<String， u64>，\n}\n\nimpl Token {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()， from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n}", "id": 14}
{"question_type": "short_answer", "instructions": "Complete the smart contract voting system by implementing proper ownership patterns for vote delegation while avoiding move semantics issues", "contract_code": "struct Vote {\n    proposal_id: u32，\n    voter: String，\n    weight: u32，\n}\n\nstruct VotingSystem {\n    votes: Vec<Vote>，\n    delegates: std::collections::HashMap<String， String>，\n}\n\nimpl VotingSystem {\n    fn delegate_vote(&mut self， delegator: String， delegate: String) {\n        self.delegates.insert(delegator， delegate);\n    }\n    \n    fn cast_vote(&mut self， vote: Vote) {\n        let effective_voter = self.get_effective_voter(vote.voter);\n        let delegated_vote = Vote {\n            proposal_id: vote.proposal_id，\n            voter: effective_voter，\n            weight: vote.weight，\n        };\n        self.votes.push(delegated_vote);\n    }\n    \n    fn get_effective_voter(&self， voter: String) -> String {\n        // TODO: Implement without ownership issues\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "implements_borrow_pattern", "points": 3, "keywords": ["borrow", "reference", "clone", "lifetime"]}, {"criterion": "avoids_move_semantics", "points": 2, "check_function": "check_no_unnecessary_moves"}, {"criterion": "handles_delegation_chain", "points": 2, "check_function": "validate_delegation_logic"}], "automated_tests": ["test_vote_delegation", "test_delegation_chain"], "reference_solution": "fn get_effective_voter(&self， voter: String) -> String {\n    match self.delegates.get(&voter) {\n        Some(delegate) => delegate.clone()，\n        None => voter，\n    }\n}", "id": 15}
{"question_type": "short_answer", "instructions": "Optimize this asset management contract to eliminate unnecessary cloning and improve borrowing patterns for better performance", "contract_code": "struct Asset {\n    id: String，\n    owner: String，\n    metadata: std::collections::HashMap<String， String>，\n}\n\nstruct AssetRegistry {\n    assets: std::collections::HashMap<String， Asset>，\n}\n\nimpl AssetRegistry {\n    fn transfer_asset(&mut self， asset_id: String， new_owner: String) -> Result<()， &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset.clone();\n        updated_asset.owner = new_owner;\n        self.assets.insert(asset_id， updated_asset);\n        Ok(())\n    }\n    \n    fn get_asset_owner(&self， asset_id: String) -> Option<String> {\n        self.assets.get(&asset_id).map(|asset| asset.owner.clone())\n    }\n    \n    fn update_metadata(&mut self， asset_id: String， key: String， value: String) -> Result<()， &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset;\n        updated_asset.metadata.insert(key， value);\n        self.assets.insert(asset_id， updated_asset);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 1, "keywords": ["clone", "unnecessary", "reference"]}, {"criterion": "optimizes_mutable_access", "points": 4, "check_function": "check_direct_mutation"}, {"criterion": "improves_string_handling", "points": 2, "check_function": "validate_string_borrowing"}], "automated_tests": ["test_asset_transfer", "test_metadata_update"], "reference_solution": "impl AssetRegistry {\n    fn transfer_asset(&mut self， asset_id: &str， new_owner: String) -> Result<()， &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.owner = new_owner;\n        Ok(())\n    }\n    \n    fn get_asset_owner(&self， asset_id: &str) -> Option<&str> {\n        self.assets.get(asset_id).map(|asset| asset.owner.as_str())\n    }\n    \n    fn update_metadata(&mut self， asset_id: &str， key: String， value: String) -> Result<()， &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.metadata.insert(key， value);\n        Ok(())\n    }\n}", "id": 16}
{"question_type": "short_answer", "instructions": "Debug the failing test cases for this escrow contract by identifying and fixing the borrowing conflicts that prevent compilation", "contract_code": "struct Escrow {\n    funds: std::collections::HashMap<String， u64>，\n    pending_releases: Vec<String>，\n}\n\nimpl Escrow {\n    fn deposit(&mut self， account: String， amount: u64) {\n        let balance = self.funds.entry(account.clone()).or_insert(0);\n        *balance += amount;\n        self.pending_releases.push(account);\n    }\n    \n    fn release_funds(&mut self， account: &str) -> Result<u64， &'static str> {\n        let funds = self.funds.get(account).ok_or(\"No funds found\")?;\n        let amount = *funds;\n        self.funds.remove(account);\n        self.pending_releases.retain(|acc| acc != account);\n        Ok(amount)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_escrow_operations() {\n        let mut escrow = Escrow {\n            funds: std::collections::HashMap::new()，\n            pending_releases: Vec::new()，\n        };\n        \n        escrow.deposit(\"alice\".to_string()， 100);\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        let pending = &escrow.pending_releases;\n        assert_eq!(*balance， 100);\n        assert!(pending.contains(&\"alice\".to_string()));\n        \n        let released = escrow.release_funds(\"alice\").unwrap();\n        assert_eq!(released， 100);\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_conflict", "points": 2, "keywords": ["borrow", "conflict", "immutable", "mutable"]}, {"criterion": "fixes_test_borrowing", "points": 2, "check_function": "check_test_compilation"}, {"criterion": "maintains_test_logic", "points": 3, "check_function": "validate_test_assertions"}], "automated_tests": ["test_escrow_operations", "test_multiple_deposits"], "reference_solution": "#[test]\nfn test_escrow_operations() {\n    let mut escrow = Escrow {\n        funds: std::collections::HashMap::new()，\n        pending_releases: Vec::new()，\n    };\n    \n    escrow.deposit(\"alice\".to_string()， 100);\n    {\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        assert_eq!(*balance， 100);\n    }\n    assert!(escrow.pending_releases.contains(&\"alice\".to_string()));\n    \n    let released = escrow.release_funds(\"alice\").unwrap();\n    assert_eq!(released， 100);\n}", "id": 17}
{"question_type": "short_answer", "instructions": "Refactor this monolithic smart contract into a modular architecture using the Strategy pattern for different token distribution mechanisms. Implement proper trait abstractions and demonstrate how to swap distribution strategies at runtime.", "contract_code": "struct TokenDistributor {\n    balance: u64，\n    distribution_type: String，\n}\n\nimpl TokenDistributor {\n    fn distribute(&mut self， amount: u64， recipients: Vec<String>) -> Result<()， String> {\n        if self.distribution_type == \"equal\" {\n            let per_recipient = amount / recipients.len() as u64;\n            self.balance -= amount;\n            println!(\"Equal distribution: {} per recipient\"， per_recipient);\n        } else if self.distribution_type == \"weighted\" {\n            // Hardcoded weighted logic\n            self.balance -= amount;\n            println!(\"Weighted distribution\");\n        } else if self.distribution_type == \"lottery\" {\n            // Hardcoded lottery logic\n            self.balance -= amount;\n            println!(\"Lottery distribution\");\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "strategy", "abstraction"]}, {"criterion": "demonstrates_modular_architecture", "points": 2, "keywords": ["modular", "separation", "decoupled"]}, {"criterion": "enables_runtime_strategy_swapping", "points": 2, "check_function": "check_strategy_swapping"}], "automated_tests": ["test_strategy_pattern", "test_runtime_swapping"], "reference_solution": "trait DistributionStrategy {\n    fn distribute(&self， amount: u64， recipients: &[String]) -> Result<()， String>;\n}\n\nstruct EqualDistribution;\nstruct WeightedDistribution;\nstruct LotteryDistribution;\n\nimpl DistributionStrategy for EqualDistribution {\n    fn distribute(&self， amount: u64， recipients: &[String]) -> Result<()， String> {\n        let per_recipient = amount / recipients.len() as u64;\n        println!(\"Equal: {} per recipient\"， per_recipient);\n        Ok(())\n    }\n}\n\nstruct TokenDistributor {\n    balance: u64，\n    strategy: Box<dyn DistributionStrategy>，\n}\n\nimpl TokenDistributor {\n    fn set_strategy(&mut self， strategy: Box<dyn DistributionStrategy>) {\n        self.strategy = strategy;\n    }\n    \n    fn distribute(&mut self， amount: u64， recipients: Vec<String>) -> Result<()， String> {\n        if self.balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balance -= amount;\n        self.strategy.distribute(amount， &recipients)\n    }\n}", "id": 18}
{"question_type": "code_audit", "instructions": "This contract attempts to implement a Factory pattern for creating different types of accounts， but has critical ownership and lifetime issues. Identify the problems and provide a corrected implementation that properly manages object lifetimes and ownership.", "contract_code": "struct Account {\n    id: u32，\n    balance: u64，\n    account_type: String，\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<&Account>，\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()，\n        }\n    }\n    \n    fn create_account(&mut self， id: u32， account_type: String) -> &Account {\n        let account = Account {\n            id，\n            balance: 0，\n            account_type，\n        };\n        self.created_accounts.push(&account);\n        &account\n    }\n    \n    fn get_account(&self， id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id).copied()\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_lifetime_issues", "points": 2, "keywords": ["lifetime", "dangling", "reference"]}, {"criterion": "fixes_ownership_model", "points": 4, "check_function": "check_ownership_fix"}, {"criterion": "maintains_factory_pattern", "points": 1, "keywords": ["factory", "pattern"]}], "automated_tests": ["test_factory_creation", "test_account_retrieval"], "reference_solution": "struct Account {\n    id: u32，\n    balance: u64，\n    account_type: String，\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<Account>，\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()，\n        }\n    }\n    \n    fn create_account(&mut self， id: u32， account_type: String) -> &Account {\n        let account = Account {\n            id，\n            balance: 0，\n            account_type，\n        };\n        self.created_accounts.push(account);\n        self.created_accounts.last().unwrap()\n    }\n    \n    fn get_account(&self， id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id)\n    }\n}", "id": 19}
{"question_type": "short_answer", "instructions": "Optimize this Observer pattern implementation for a smart contract event system. The current design has performance issues with event notification and memory usage. Refactor to use efficient data structures and minimize allocations while maintaining the observer pattern's flexibility.", "contract_code": "use std::collections::HashMap;\n\ntrait EventObserver {\n    fn on_event(&self， event: String， data: HashMap<String， String>);\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<String， Vec<Box<dyn EventObserver>>>，\n    event_history: Vec<(String， HashMap<String， String>)>，\n}\n\nimpl ContractEventSystem {\n    fn new() -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()，\n            event_history: Vec::new()，\n        }\n    }\n    \n    fn subscribe(&mut self， event_type: String， observer: Box<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut self， event_type: String， data: HashMap<String， String>) {\n        // Store full event history (memory intensive)\n        self.event_history.push((event_type.clone()， data.clone()));\n        \n        // Notify all observers (inefficient cloning)\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(event_type.clone()， data.clone());\n            }\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "optimizes_memory_usage", "points": 2, "keywords": ["memory", "allocation", "efficient"]}, {"criterion": "reduces_clone_operations", "points": 2, "keywords": ["clone", "borrow", "reference"]}, {"criterion": "maintains_observer_pattern", "points": 3, "check_function": "check_observer_pattern"}], "automated_tests": ["test_optimized_notifications", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\n\ntrait EventObserver {\n    fn on_event(&self， event: &str， data: &HashMap<String， String>);\n}\n\nstruct EventData {\n    event_type: String，\n    data: HashMap<String， String>，\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<String， Vec<Rc<dyn EventObserver>>>，\n    event_history: Vec<Rc<EventData>>，\n    max_history: usize，\n}\n\nimpl ContractEventSystem {\n    fn new(max_history: usize) -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()，\n            event_history: Vec::new()，\n            max_history，\n        }\n    }\n    \n    fn subscribe(&mut self， event_type: String， observer: Rc<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut self， event_type: String， data: HashMap<String， String>) {\n        let event_data = Rc::new(EventData { event_type: event_type.clone()， data });\n        \n        // Bounded history to prevent memory leaks\n        if self.event_history.len() >= self.max_history {\n            self.event_history.remove(0);\n        }\n        self.event_history.push(event_data.clone());\n        \n        // Efficient notification using references\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(&event_data.event_type， &event_data.data);\n            }\n        }\n    }\n}", "id": 20}
{"question_type": "refactoring", "instructions": "Refactor this tightly coupled smart contract system into a clean， modular architecture using dependency injection and the Command pattern. The current implementation violates single responsibility principle and makes testing difficult. Implement proper abstractions and demonstrate how the new design improves maintainability.", "contract_code": "struct WalletManager {\n    balances: std::collections::HashMap<String， u64>，\n    transaction_log: Vec<String>，\n}\n\nimpl WalletManager {\n    fn new() -> Self {\n        WalletManager {\n            balances: std::collections::HashMap::new()，\n            transaction_log: Vec::new()，\n        }\n    }\n    \n    fn transfer(&mut self， from: String， to: String， amount: u64) -> Result<()， String> {\n        // Validation logic mixed with business logic\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balances.get(&from).unwrap_or(&0);\n        if *from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        // Direct state manipulation\n        self.balances.insert(from.clone()， from_balance - amount);\n        let to_balance = self.balances.get(&to).unwrap_or(&0);\n        self.balances.insert(to.clone()， to_balance + amount);\n        \n        // Logging tightly coupled\n        self.transaction_log.push(format!(\"Transfer: {} -> {}: {}\"， from， to， amount));\n        \n        // Hardcoded notification\n        println!(\"Transfer completed: {} to {}\"， from， to);\n        \n        Ok(())\n    }\n    \n    fn get_balance(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_dependency_injection", "points": 1, "keywords": ["dependency", "injection", "decoupled"]}, {"criterion": "applies_command_pattern", "points": 4, "check_function": "check_command_pattern"}, {"criterion": "separates_concerns", "points": 2, "keywords": ["separation", "responsibility", "modular"]}], "automated_tests": ["test_command_execution", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\n\ntrait BalanceStore {\n    fn get_balance(&self， account: &str) -> u64;\n    fn set_balance(&mut self， account: &str， amount: u64);\n}\n\ntrait TransactionLogger {\n    fn log(&mut self， message: String);\n}\n\ntrait NotificationService {\n    fn notify(&self， message: String);\n}\n\nstruct InMemoryBalanceStore {\n    balances: HashMap<String， u64>，\n}\n\nimpl BalanceStore for InMemoryBalanceStore {\n    fn get_balance(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n    \n    fn set_balance(&mut self， account: &str， amount: u64) {\n        self.balances.insert(account.to_string()， amount);\n    }\n}\n\ntrait Command {\n    fn execute(&self， wallet: &mut WalletManager) -> Result<()， String>;\n}\n\nstruct TransferCommand {\n    from: String，\n    to: String，\n    amount: u64，\n}\n\nimpl Command for TransferCommand {\n    fn execute(&self， wallet: &mut WalletManager) -> Result<()， String> {\n        wallet.transfer(self.from.clone()， self.to.clone()， self.amount)\n    }\n}\n\nstruct WalletManager {\n    balance_store: Box<dyn BalanceStore>，\n    logger: Box<dyn TransactionLogger>，\n    notifier: Box<dyn NotificationService>，\n}\n\nimpl WalletManager {\n    fn new(balance_store: Box<dyn BalanceStore>， logger: Box<dyn TransactionLogger>， notifier: Box<dyn NotificationService>) -> Self {\n        WalletManager { balance_store， logger， notifier }\n    }\n    \n    fn transfer(&mut self， from: String， to: String， amount: u64) -> Result<()， String> {\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balance_store.get_balance(&from);\n        if from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        self.balance_store.set_balance(&from， from_balance - amount);\n        let to_balance = self.balance_store.get_balance(&to);\n        self.balance_store.set_balance(&to， to_balance + amount);\n        \n        self.logger.log(format!(\"Transfer: {} -> {}: {}\"， from， to， amount));\n        self.notifier.notify(format!(\"Transfer completed: {} to {}\"， from， to));\n        \n        Ok(())\n    }\n    \n    fn execute_command(&mut self， command: Box<dyn Command>) -> Result<()， String> {\n        command.execute(self)\n    }\n}", "id": 21}
{"question_type": "short_answer", "instructions": "Optimize this inefficient token transfer function that clones vectors unnecessarily and uses inappropriate data structures for performance", "contract_code": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: String，\n    to: String，\n    amount: u64，\n}\n\nstruct TokenContract {\n    balances: HashMap<String， u64>，\n    transactions: Vec<Transaction>，\n}\n\nimpl TokenContract {\n    fn transfer(&mut self， from: String， to: String， amount: u64) -> Result<()， String> {\n        let mut temp_transactions = self.transactions.clone();\n        let tx = Transaction { from: from.clone()， to: to.clone()， amount };\n        temp_transactions.push(tx.clone());\n        \n        if let Some(from_balance) = self.balances.get(&from) {\n            if *from_balance >= amount {\n                self.balances.insert(from.clone()， from_balance - amount);\n                let to_balance = self.balances.get(&to).unwrap_or(&0);\n                self.balances.insert(to.clone()， to_balance + amount);\n                self.transactions = temp_transactions;\n                Ok(())\n            } else {\n                Err(\"Insufficient balance\".to_string())\n            }\n        } else {\n            Err(\"Account not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 3, "keywords": ["clone", "unnecessary", "borrow", "reference"]}, {"criterion": "optimizes_data_structures", "points": 2, "keywords": ["HashMap", "entry", "or_insert", "get_mut"]}, {"criterion": "improves_memory_efficiency", "points": 2, "check_function": "check_memory_short_answer"}], "automated_tests": ["test_transfer_performance", "test_memory_usage"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: String，\n    to: String，\n    amount: u64，\n}\n\nstruct TokenContract {\n    balances: HashMap<String， u64>，\n    transactions: Vec<Transaction>，\n}\n\nimpl TokenContract {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        let from_balance = self.balances.entry(from.to_string()).or_insert(0);\n        if *from_balance >= amount {\n            *from_balance -= amount;\n            *self.balances.entry(to.to_string()).or_insert(0) += amount;\n            self.transactions.push(Transaction { \n                from: from.to_string()， \n                to: to.to_string()， \n                amount \n            });\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\".to_string())\n        }\n    }\n}", "id": 22}
{"question_type": "code_audit", "instructions": "Identify and fix the resource management issue in this contract that causes memory leaks and inefficient resource usage", "contract_code": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64，\n    data: Vec<u8>，\n    metadata: String，\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64， DataStorage>，\n    next_id: u64，\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()，\n            next_id: 1，\n        }\n    }\n    \n    fn store_data(&mut self， data: Vec<u8>， metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage {\n            id，\n            data: data.clone()，\n            metadata: metadata.clone()，\n        };\n        \n        self.storage_map.insert(id， storage);\n        id\n    }\n    \n    fn get_data(&self， id: u64) -> Option<Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| storage.data.clone())\n    }\n    \n    fn update_metadata(&mut self， id: u64， new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata.clone();\n            true\n        } else {\n            false\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_memory_leak", "points": 2, "keywords": ["clone", "memory", "leak", "unnecessary"]}, {"criterion": "fixes_resource_management", "points": 4, "check_function": "check_resource_short_answer"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_storage_contract"}], "automated_tests": ["test_storage_operations", "test_memory_efficiency"], "reference_solution": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64，\n    data: Vec<u8>，\n    metadata: String，\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64， DataStorage>，\n    next_id: u64，\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()，\n            next_id: 1，\n        }\n    }\n    \n    fn store_data(&mut self， data: Vec<u8>， metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage { id， data， metadata };\n        self.storage_map.insert(id， storage);\n        id\n    }\n    \n    fn get_data(&self， id: u64) -> Option<&Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| &storage.data)\n    }\n    \n    fn update_metadata(&mut self， id: u64， new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata;\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 23}
{"question_type": "short_answer", "instructions": "Implement an efficient object pool pattern for this smart contract to reduce allocation overhead and improve performance for frequently created/destroyed objects", "contract_code": "struct Order {\n    id: u64，\n    user_id: u64，\n    amount: u64，\n    price: u64，\n    is_active: bool，\n}\n\nstruct OrderBook {\n    orders: Vec<Order>，\n    next_id: u64，\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            orders: Vec::new()，\n            next_id: 1，\n        }\n    }\n    \n    fn create_order(&mut self， user_id: u64， amount: u64， price: u64) -> u64 {\n        let order = Order {\n            id: self.next_id，\n            user_id，\n            amount，\n            price，\n            is_active: true，\n        };\n        self.next_id += 1;\n        self.orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut self， order_id: u64) -> bool {\n        if let Some(order) = self.orders.iter_mut().find(|o| o.id == order_id) {\n            order.is_active = false;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn cleanup_inactive_orders(&mut self) {\n        self.orders.retain(|order| order.is_active);\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_object_pool", "points": 1, "keywords": ["pool", "reuse", "allocate", "deallocate"]}, {"criterion": "reduces_allocation_overhead", "points": 2, "keywords": ["allocation", "overhead", "performance", "efficiency"]}, {"criterion": "maintains_memory_efficiency", "points": 3, "check_function": "check_pool_implementation"}], "automated_tests": ["test_object_pool_performance", "test_order_lifecycle"], "reference_solution": "struct Order {\n    id: u64，\n    user_id: u64，\n    amount: u64，\n    price: u64，\n    is_active: bool，\n}\n\nstruct OrderPool {\n    available: Vec<Order>，\n    capacity: usize，\n}\n\nimpl OrderPool {\n    fn new(capacity: usize) -> Self {\n        Self {\n            available: Vec::with_capacity(capacity)，\n            capacity，\n        }\n    }\n    \n    fn get_order(&mut self， id: u64， user_id: u64， amount: u64， price: u64) -> Order {\n        if let Some(mut order) = self.available.pop() {\n            order.id = id;\n            order.user_id = user_id;\n            order.amount = amount;\n            order.price = price;\n            order.is_active = true;\n            order\n        } else {\n            Order { id， user_id， amount， price， is_active: true }\n        }\n    }\n    \n    fn return_order(&mut self， order: Order) {\n        if self.available.len() < self.capacity {\n            self.available.push(order);\n        }\n    }\n}\n\nstruct OrderBook {\n    active_orders: Vec<Order>，\n    order_pool: OrderPool，\n    next_id: u64，\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            active_orders: Vec::new()，\n            order_pool: OrderPool::new(100)，\n            next_id: 1，\n        }\n    }\n    \n    fn create_order(&mut self， user_id: u64， amount: u64， price: u64) -> u64 {\n        let order = self.order_pool.get_order(self.next_id， user_id， amount， price);\n        self.next_id += 1;\n        self.active_orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut self， order_id: u64) -> bool {\n        if let Some(pos) = self.active_orders.iter().position(|o| o.id == order_id) {\n            let order = self.active_orders.remove(pos);\n            self.order_pool.return_order(order);\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 24}
{"question_type": "short_answer", "instructions": "Optimize this batch processing function to handle large datasets efficiently without causing stack overflow or excessive memory usage", "contract_code": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<String， Vec<u64>>，\n    results: Vec<ProcessingResult>，\n}\n\nstruct ProcessingResult {\n    key: String，\n    sum: u64，\n    count: usize，\n    average: f64，\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()，\n            results: Vec::new()，\n        }\n    }\n    \n    fn process_batch(&mut self， batch_data: Vec<(String， Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::new();\n        \n        for (key， values) in batch_data {\n            // Store in cache\n            self.data_cache.insert(key.clone()， values.clone());\n            \n            // Process immediately\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()，\n                sum，\n                count，\n                average，\n            };\n            \n            results.push(result.clone());\n            self.results.push(result);\n        }\n        \n        results\n    }\n    \n    fn get_cached_data(&self， key: &str) -> Option<Vec<u64>> {\n        self.data_cache.get(key).cloned()\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 2, "keywords": ["clone", "reference", "borrow", "move"]}, {"criterion": "optimizes_batch_processing", "points": 2, "keywords": ["iterator", "chunks", "streaming", "batch"]}, {"criterion": "improves_memory_management", "points": 3, "check_function": "check_batch_short_answer"}], "automated_tests": ["test_large_batch_processing", "test_memory_usage_short_answer"], "reference_solution": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<String， Vec<u64>>，\n    results: Vec<ProcessingResult>，\n}\n\nstruct ProcessingResult {\n    key: String，\n    sum: u64，\n    count: usize，\n    average: f64，\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()，\n            results: Vec::new()，\n        }\n    }\n    \n    fn process_batch(&mut self， batch_data: Vec<(String， Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::with_capacity(batch_data.len());\n        \n        for (key， values) in batch_data {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()，\n                sum，\n                count，\n                average，\n            };\n            \n            results.push(result);\n            self.data_cache.insert(key， values);\n        }\n        \n        self.results.extend(results.iter().cloned());\n        results\n    }\n    \n    fn get_cached_data(&self， key: &str) -> Option<&Vec<u64>> {\n        self.data_cache.get(key)\n    }\n    \n    fn process_streaming(&mut self， data_stream: impl Iterator<Item = (String， Vec<u64>)>) -> impl Iterator<Item = ProcessingResult> + '_ {\n        data_stream.map(|(key， values)| {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult { key: key.clone()， sum， count， average };\n            self.data_cache.insert(key， values);\n            result\n        })\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "id": 25}
{"question_type": "short_answer", "instructions": "Write comprehensive unit tests for this token contract focusing on edge cases and proper error handling. Identify any missing test scenarios.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debug， PartialEq)]\npub enum TokenError {\n    InsufficientBalance，\n    InvalidAmount，\n}\n\npub struct Token {\n    balances: HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl Token {\n    pub fn new(initial_supply: u64) -> Self {\n        let mut balances = HashMap::new();\n        balances.insert(\"owner\".to_string()， initial_supply);\n        Token { balances， total_supply: initial_supply }\n    }\n    \n    pub fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， TokenError> {\n        if amount == 0 { return Err(TokenError::InvalidAmount); }\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance < amount { return Err(TokenError::InsufficientBalance); }\n        \n        self.balances.insert(from.to_string()， from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n    \n    pub fn balance(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "tests_edge_cases", "points": 3, "keywords": ["zero_amount", "nonexistent_account", "overflow"]}, {"criterion": "proper_test_structure", "points": 2, "keywords": ["#[test]", "assert_eq", "assert"]}, {"criterion": "error_handling_tests", "points": 2, "keywords": ["Result", "unwrap", "expect", "match"]}], "automated_tests": ["test_token_functionality", "test_error_scenarios"], "reference_solution": "#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_transfer_success() {\n        let mut token = Token::new(1000);\n        assert!(token.transfer(\"owner\"， \"alice\"， 100).is_ok());\n        assert_eq!(token.balance(\"alice\")， 100);\n        assert_eq!(token.balance(\"owner\")， 900);\n    }\n    \n    #[test]\n    fn test_insufficient_balance() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"alice\"， \"bob\"， 100)， Err(TokenError::InsufficientBalance));\n    }\n    \n    #[test]\n    fn test_zero_amount_transfer() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"owner\"， \"alice\"， 0)， Err(TokenError::InvalidAmount));\n    }\n}", "id": 26}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this staking contract and provide a secure implementation with proper overflow checks.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingPool {\n    stakes: HashMap<String， u64>，\n    rewards: HashMap<String， u64>，\n    reward_rate: u64，\n}\n\nimpl StakingPool {\n    pub fn new(reward_rate: u64) -> Self {\n        StakingPool {\n            stakes: HashMap::new()，\n            rewards: HashMap::new()，\n            reward_rate，\n        }\n    }\n    \n    pub fn stake(&mut self， user: &str， amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()， current_stake + amount);\n    }\n    \n    pub fn calculate_rewards(&mut self， user: &str， time_elapsed: u64) {\n        let stake_amount = self.stakes.get(user).unwrap_or(&0);\n        let reward = stake_amount * self.reward_rate * time_elapsed / 100;\n        let current_rewards = self.rewards.get(user).unwrap_or(&0);\n        self.rewards.insert(user.to_string()， current_rewards + reward);\n    }\n    \n    pub fn get_stake(&self， user: &str) -> u64 {\n        *self.stakes.get(user).unwrap_or(&0)\n    }\n    \n    pub fn get_rewards(&self， user: &str) -> u64 {\n        *self.rewards.get(user).unwrap_or(&0)\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 2, "keywords": ["overflow", "saturating", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_overflow_protection"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_contract_logic"}], "automated_tests": ["test_overflow_protection", "test_staking_functionality"], "reference_solution": "pub fn stake(&mut self， user: &str， amount: u64) {\n    let current_stake = self.stakes.get(user).unwrap_or(&0);\n    self.stakes.insert(user.to_string()， current_stake.saturating_add(amount));\n}\n\npub fn calculate_rewards(&mut self， user: &str， time_elapsed: u64) -> Result<()， &'static str> {\n    let stake_amount = self.stakes.get(user).unwrap_or(&0);\n    let reward = stake_amount.checked_mul(self.reward_rate)\n        .and_then(|r| r.checked_mul(time_elapsed))\n        .and_then(|r| r.checked_div(100))\n        .ok_or(\"Reward calculation overflow\")?;\n    let current_rewards = self.rewards.get(user).unwrap_or(&0);\n    self.rewards.insert(user.to_string()， current_rewards.saturating_add(reward));\n    Ok(())\n}", "id": 27}
{"question_type": "short_answer", "instructions": "Refactor this voting contract to implement proper state management using Rust's ownership system and eliminate the use of RefCell for thread-safe state mutations.", "contract_code": "use std::collections::HashMap;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Clone)]\npub struct Proposal {\n    id: u32，\n    title: String，\n    votes_for: u32，\n    votes_against: u32，\n    active: bool，\n}\n\npub struct VotingSystem {\n    proposals: Rc<RefCell<HashMap<u32， Proposal>>>，\n    voters: Rc<RefCell<HashMap<String， Vec<u32>>>>，\n    next_id: Rc<RefCell<u32>>，\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: Rc::new(RefCell::new(HashMap::new()))，\n            voters: Rc::new(RefCell::new(HashMap::new()))，\n            next_id: Rc::new(RefCell::new(1))，\n        }\n    }\n    \n    pub fn create_proposal(&self， title: String) -> u32 {\n        let id = *self.next_id.borrow();\n        *self.next_id.borrow_mut() += 1;\n        \n        let proposal = Proposal {\n            id，\n            title，\n            votes_for: 0，\n            votes_against: 0，\n            active: true，\n        };\n        \n        self.proposals.borrow_mut().insert(id， proposal);\n        id\n    }\n    \n    pub fn vote(&self， voter: &str， proposal_id: u32， vote_for: bool) -> Result<()， String> {\n        let mut voted_proposals = self.voters.borrow_mut();\n        let user_votes = voted_proposals.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.borrow_mut().get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "eliminates_refcell_usage", "points": 2, "keywords": ["RefCell", "interior_mutability", "ownership"]}, {"criterion": "implements_proper_ownership", "points": 2, "keywords": ["&mut self", "borrow", "move"]}, {"criterion": "maintains_thread_safety", "points": 3, "keywords": ["Send", "Sync", "thread_safe", "mutex"]}], "automated_tests": ["test_voting_functionality", "test_thread_safety"], "reference_solution": "pub struct VotingSystem {\n    proposals: HashMap<u32， Proposal>，\n    voters: HashMap<String， Vec<u32>>，\n    next_id: u32，\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: HashMap::new()，\n            voters: HashMap::new()，\n            next_id: 1，\n        }\n    }\n    \n    pub fn create_proposal(&mut self， title: String) -> u32 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let proposal = Proposal {\n            id，\n            title，\n            votes_for: 0，\n            votes_against: 0，\n            active: true，\n        };\n        \n        self.proposals.insert(id， proposal);\n        id\n    }\n    \n    pub fn vote(&mut self， voter: &str， proposal_id: u32， vote_for: bool) -> Result<()， String> {\n        let user_votes = self.voters.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 28}
{"question_type": "short_answer", "instructions": "Debug and optimize this auction contract that has performance issues with large numbers of bidders. Identify bottlenecks and implement efficient data structures.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debug， Clone)]\npub struct Bid {\n    bidder: String，\n    amount: u64，\n    timestamp: u64，\n}\n\npub struct Auction {\n    item_id: u32，\n    all_bids: Vec<Bid>，\n    bidder_amounts: HashMap<String， u64>，\n    end_time: u64，\n}\n\nimpl Auction {\n    pub fn new(item_id: u32， end_time: u64) -> Self {\n        Auction {\n            item_id，\n            all_bids: Vec::new()，\n            bidder_amounts: HashMap::new()，\n            end_time，\n        }\n    }\n    \n    pub fn place_bid(&mut self， bidder: String， amount: u64， timestamp: u64) -> Result<()， String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        // Check if bid is higher than current highest\n        let current_highest = self.get_highest_bid();\n        if amount <= current_highest {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        let bid = Bid { bidder: bidder.clone()， amount， timestamp };\n        self.all_bids.push(bid);\n        self.bidder_amounts.insert(bidder， amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        let mut highest = 0;\n        for bid in &self.all_bids {\n            if bid.amount > highest {\n                highest = bid.amount;\n            }\n        }\n        highest\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        let highest_amount = self.get_highest_bid();\n        for bid in &self.all_bids {\n            if bid.amount == highest_amount {\n                return Some(bid.bidder.clone());\n            }\n        }\n        None\n    }\n    \n    pub fn get_bid_history(&self) -> Vec<Bid> {\n        let mut sorted_bids = self.all_bids.clone();\n        sorted_bids.sort_by(|a， b| b.amount.cmp(&a.amount));\n        sorted_bids\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_performance_bottlenecks", "points": 1, "keywords": ["O(n)", "linear_search", "inefficient"]}, {"criterion": "implements_efficient_data_structures", "points": 4, "keywords": ["BTreeMap", "heap", "binary_search", "short_answer"]}, {"criterion": "maintains_correctness", "points": 2, "check_function": "validate_auction_logic"}], "automated_tests": ["test_auction_performance", "test_bid_correctness"], "reference_solution": "use std::collections::{HashMap， BTreeMap};\n\npub struct Auction {\n    item_id: u32，\n    highest_bid: u64，\n    highest_bidder: Option<String>，\n    bid_history: BTreeMap<u64， (String， u64)>， // amount -> (bidder， timestamp)\n    bidder_amounts: HashMap<String， u64>，\n    end_time: u64，\n}\n\nimpl Auction {\n    pub fn new(item_id: u32， end_time: u64) -> Self {\n        Auction {\n            item_id，\n            highest_bid: 0，\n            highest_bidder: None，\n            bid_history: BTreeMap::new()，\n            bidder_amounts: HashMap::new()，\n            end_time，\n        }\n    }\n    \n    pub fn place_bid(&mut self， bidder: String， amount: u64， timestamp: u64) -> Result<()， String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        if amount <= self.highest_bid {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        self.highest_bid = amount;\n        self.highest_bidder = Some(bidder.clone());\n        self.bid_history.insert(amount， (bidder.clone()， timestamp));\n        self.bidder_amounts.insert(bidder， amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        self.highest_bid\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        self.highest_bidder.clone()\n    }\n}", "id": 29}
{"question_type": "code_audit", "instructions": "Identify and fix the issues in the cross-contract interface design related to error handling， specifically focusing on blockchain-specific errors like gas exhaustion and transaction reversion. Provide a revised version of the contract that includes robust error handling and ensures secure cross-contract calls.", "factors_to_consider": ["Blockchain-specific error handling", "Gas management and transaction costs", "Security of cross-contract calls", "Compatibility with existing blockchain protocols"], "keywords": ["blockchain", "gas exhaustion", "transaction reversion", "cross-contract calls", "error handling"], "expected_insights": ["Understanding of blockchain-specific error types", "Ability to implement secure and efficient cross-contract calls", "Knowledge of gas management in blockchain transactions", "Insight into maintaining protocol compatibility"], "scoring_criteria": [{"criterion": "Identifies blockchain-specific error handling issues", "points": 3, "key_points": ["Recognizes gas exhaustion", "Identifies transaction reversion"]}, {"criterion": "Implements robust error handling", "points": 3, "key_points": ["Uses Result types effectively", "Handles errors without panicking"]}, {"criterion": "Ensures secure cross-contract calls", "points": 2, "key_points": ["Prevents reentrancy attacks", "Validates external call responses"]}, {"criterion": "Maintains compatibility with blockchain protocols", "points": 2, "key_points": ["Adheres to interface standards", "Ensures backward compatibility"]}], "total_possible": 10, "id": 30, "contract_code": "// A simple contract that can be called by another contract.\n// It has a function that can either revert or consume a lot of gas.\npub mod callee {\n    use cosmwasm_std::{Response， StdError};\n\n    pub fn do_work(gas_limit: u64) -> Result<Response， StdError> {\n        if gas_limit > 100_000 {\n            // Simulate gas exhaustion\n            let mut i = 0;\n            while i < gas_limit {\n                i += 1;\n            }\n        }\n        Ok(Response::new())\n    }\n\n    pub fn do_work_and_revert() -> Result<Response， StdError> {\n        Err(StdError::generic_err(\n            \"This function is designed to revert\"，\n        ))\n    }\n}\n\n// A contract that calls the callee contract but does not handle errors properly.\npub mod caller {\n    use super::callee;\n    use cosmwasm_std::{CosmosMsg， Response， StdError， SubMsg};\n\n    pub fn call_callee_and_ignore_error(gas_limit: u64) -> Result<Response， StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()，\n            msg: cosmwasm_std::to_binary(&callee::do_work(gas_limit))?，\n            funds: vec![]，\n        });\n\n        // The error from the sub-message is not handled.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n\n    pub fn call_callee_and_panic() -> Result<Response， StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()，\n            msg: cosmwasm_std::to_binary(&callee::do_work_and_revert())?，\n            funds: vec![]，\n        });\n\n        // This will panic if the sub-message fails.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Implement a secure proxy pattern for cross-contract interactions that handles ownership of the proxied contract reference and prevents unauthorized access", "contract_code": "trait ContractInterface {\n    fn execute(&mut self， data: Vec<u8>) -> Result<Vec<u8>， String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: ContractInterface，\n    admin: String，\n}\n\nimpl ProxyContract {\n    fn new(target: ContractInterface， admin: String) -> Self {\n        Self { target， admin }\n    }\n    \n    fn call(&self， caller: String， data: Vec<u8>) -> Result<Vec<u8>， String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&self， new_target: ContractInterface) {\n        self.target = new_target;\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "fixes_ownership_issues", "points": 2, "keywords": ["Box", "dyn", "trait object"]}, {"criterion": "implements_access_control", "points": 4, "check_function": "check_access_control_logic"}, {"criterion": "handles_mutable_references", "points": 2, "check_function": "validate_mutability_handling"}], "automated_tests": ["test_proxy_authorization", "test_upgrade_security", "test_ownership_compilation"], "reference_solution": "trait ContractInterface {\n    fn execute(&mut self， data: Vec<u8>) -> Result<Vec<u8>， String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: Box<dyn ContractInterface>，\n    admin: String，\n}\n\nimpl ProxyContract {\n    fn new(target: Box<dyn ContractInterface>， admin: String) -> Self {\n        Self { target， admin }\n    }\n    \n    fn call(&mut self， caller: String， data: Vec<u8>) -> Result<Vec<u8>， String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&mut self， caller: String， new_target: Box<dyn ContractInterface>) -> Result<()， String> {\n        if caller != self.admin {\n            return Err(\"Unauthorized: Only admin can upgrade\".to_string());\n        }\n        self.target = new_target;\n        Ok(())\n    }\n}", "id": 31}
{"question_type": "short_answer", "instructions": "Optimize the cross-contract batch call system to minimize unnecessary cloning and improve memory efficiency while maintaining interface compatibility", "contract_code": "trait BatchCallable {\n    fn batch_call(&self， calls: Vec<CallData>) -> Vec<Result<Vec<u8>， String>>;\n}\n\n#[derive(Clone)]\nstruct CallData {\n    contract_address: String，\n    method: String，\n    args: Vec<u8>，\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>，\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&self， calls: Vec<CallData>) -> Vec<Result<Vec<u8>， String>> {\n        let mut results = Vec::new();\n        \n        for call in calls {\n            let contract_addr = call.contract_address.clone();\n            let method = call.method.clone();\n            let args = call.args.clone();\n            \n            let result = self.execute_single_call(contract_addr， method， args);\n            results.push(result);\n        }\n        \n        results\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&self， addr: String， method: String， args: Vec<u8>) -> Result<Vec<u8>， String> {\n        // Simulate external call\n        Ok(vec![1， 2， 3])\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 1, "keywords": ["borrow", "reference", "&"]}, {"criterion": "optimizes_memory_usage", "points": 4, "check_function": "check_memory_short_answer"}, {"criterion": "maintains_interface_contract", "points": 2, "check_function": "validate_interface_preservation"}], "automated_tests": ["test_batch_call_short_answer", "test_memory_efficiency", "test_interface_compatibility"], "reference_solution": "trait BatchCallable {\n    fn batch_call(&self， calls: &[CallData]) -> Vec<Result<Vec<u8>， String>>;\n}\n\nstruct CallData {\n    contract_address: String，\n    method: String，\n    args: Vec<u8>，\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>，\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&self， calls: &[CallData]) -> Vec<Result<Vec<u8>， String>> {\n        calls.iter()\n            .map(|call| {\n                self.execute_single_call(&call.contract_address， &call.method， &call.args)\n            })\n            .collect()\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&self， addr: &str， method: &str， args: &[u8]) -> Result<Vec<u8>， String> {\n        // Simulate external call\n        Ok(vec![1， 2， 3])\n    }\n}", "id": 32}
{"question_type": "short_answer", "instructions": "Write comprehensive tests for the cross-contract callback system and fix the callback registration mechanism that has a state management vulnerability", "contract_code": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut self， caller: String， data: Vec<u8>) -> Result<()， String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<String， Box<dyn CallbackHandler>>，\n    pending_calls: Vec<(String， Vec<u8>)>，\n}\n\nimpl CallbackRegistry {\n    fn new() -> Self {\n        Self {\n            callbacks: HashMap::new()，\n            pending_calls: Vec::new()，\n        }\n    }\n    \n    fn register_callback(&mut self， contract_id: String， handler: Box<dyn CallbackHandler>) {\n        self.callbacks.insert(contract_id， handler);\n    }\n    \n    fn execute_callback(&mut self， contract_id: String， data: Vec<u8>) -> Result<()， String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()， data)\n        } else {\n            self.pending_calls.push((contract_id， data));\n            Ok(())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_issue", "points": 2, "keywords": ["pending", "memory leak", "unbounded"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "check_function": "check_test_coverage"}, {"criterion": "fixes_state_management", "points": 3, "check_function": "validate_state_fix"}], "automated_tests": ["test_callback_registration", "test_pending_calls_handling", "test_state_cleanup"], "reference_solution": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut self， caller: String， data: Vec<u8>) -> Result<()， String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<String， Box<dyn CallbackHandler>>，\n    pending_calls: HashMap<String， Vec<Vec<u8>>>，\n    max_pending_per_contract: usize，\n}\n\nimpl CallbackRegistry {\n    fn new(max_pending: usize) -> Self {\n        Self {\n            callbacks: HashMap::new()，\n            pending_calls: HashMap::new()，\n            max_pending_per_contract: max_pending，\n        }\n    }\n    \n    fn register_callback(&mut self， contract_id: String， handler: Box<dyn CallbackHandler>) -> Result<()， String> {\n        self.callbacks.insert(contract_id.clone()， handler);\n        \n        if let Some(pending) = self.pending_calls.remove(&contract_id) {\n            for data in pending {\n                if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n                    handler.handle_callback(contract_id.clone()， data)?;\n                }\n            }\n        }\n        Ok(())\n    }\n    \n    fn execute_callback(&mut self， contract_id: String， data: Vec<u8>) -> Result<()， String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()， data)\n        } else {\n            let pending = self.pending_calls.entry(contract_id.clone()).or_insert_with(Vec::new);\n            if pending.len() >= self.max_pending_per_contract {\n                return Err(\"Too many pending callbacks for contract\".to_string());\n            }\n            pending.push(data);\n            Ok(())\n        }\n    }\n}", "id": 33}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks.", "contract_code": "pub struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl Token {\n    pub fn transfer(&mut self， from: &str， to: &str， amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()， from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()， to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 2, "check_function": "check_safe_arithmetic"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_protection", "test_normal_transfer"], "reference_solution": "pub struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl Token {\n    pub fn transfer(&mut self， from: &str， to: &str， amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()， from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()， new_balance);\n                    return true;\n                }\n                None => return false，\n            }\n        }\n        false\n    }\n}", "id": 34}
{"question_type": "short_answer", "instructions": "Fix the access control vulnerability in this governance contract by implementing proper authorization checks and state management patterns.", "contract_code": "pub struct GovernanceContract {\n    owner: String，\n    proposals: Vec<Proposal>，\n    voting_power: std::collections::HashMap<String， u32>，\n}\n\npub struct Proposal {\n    id: u32，\n    description: String，\n    votes_for: u32，\n    votes_against: u32，\n    executed: bool，\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut self， proposal_id: u32， executor: &str) {\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            proposal.executed = true;\n            // Execute proposal logic here\n        }\n    }\n    \n    pub fn vote(&mut self， voter: &str， proposal_id: u32， support: bool) {\n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n        }\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "identifies_access_control_flaws", "points": 2, "keywords": ["authorization", "permission", "access", "security"]}, {"criterion": "implements_proper_checks", "points": 4, "check_function": "check_access_control"}, {"criterion": "prevents_unauthorized_execution", "points": 1, "check_function": "validate_authorization"}], "automated_tests": ["test_unauthorized_execution", "test_double_voting", "test_valid_execution"], "reference_solution": "pub struct GovernanceContract {\n    owner: String，\n    proposals: Vec<Proposal>，\n    voting_power: std::collections::HashMap<String， u32>，\n    voted: std::collections::HashMap<(String， u32)， bool>，\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut self， proposal_id: u32， executor: &str) -> Result<()， String> {\n        if executor != self.owner {\n            return Err(\"Unauthorized executor\".to_string());\n        }\n        \n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            if proposal.votes_for <= proposal.votes_against {\n                return Err(\"Insufficient votes\".to_string());\n            }\n            proposal.executed = true;\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n    \n    pub fn vote(&mut self， voter: &str， proposal_id: u32， support: bool) -> Result<()， String> {\n        let vote_key = (voter.to_string()， proposal_id);\n        if self.voted.contains_key(&vote_key) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            self.voted.insert(vote_key， true);\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 35}
{"question_type": "code_audit", "instructions": "Identify and fix the error handling vulnerability in this staking contract that could lead to panics and denial of service attacks. Address the specific issues related to token decimal handling， error handling robustness， and ensure all potential edge cases are covered.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingContract {\n    stakes: HashMap<String， u64>，\n    rewards: HashMap<String， u64>，\n    total_staked: u64，\n}\n\nimpl StakingContract {\n    pub fn stake(&mut self， user: &str， amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        self.stakes.insert(user.to_string()， current_stake + amount);\n        self.total_staked += amount;\n    }\n    \n    pub fn unstake(&mut self， user: &str， amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        assert!(current_stake >= &amount， \"Insufficient stake\");\n        self.stakes.insert(user.to_string()， current_stake - amount);\n        self.total_staked -= amount;\n    }\n    \n    pub fn claim_rewards(&mut self， user: &str) -> u64 {\n        let reward = self.rewards.get(user).unwrap();\n        self.rewards.insert(user.to_string()， 0);\n        *reward\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_vulnerabilities", "points": 2, "keywords": ["panic", "unwrap", "assert", "Result"]}, {"criterion": "implements_safe_error_handling", "points": 2, "check_function": "check_error_handling"}, {"criterion": "maintains_contract_robustness", "points": 3, "check_function": "validate_robustness"}], "automated_tests": ["test_panic_prevention", "test_error_propagation", "test_edge_cases", "test_decimal_token_support"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Debug)]\npub enum StakingError {\n    UserNotFound，\n    InsufficientStake，\n    NoRewards，\n    InvalidDecimalToken，\n}\n\npub struct StakingContract {\n    stakes: HashMap<String， u64>，\n    rewards: HashMap<String， u64>，\n    total_staked: u64，\n}\n\nimpl StakingContract {\n    pub fn stake(&mut self， user: &str， amount: u64) -> Result<()， StakingError> {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()， current_stake + amount);\n        self.total_staked += amount;\n        Ok(())\n    }\n    \n    pub fn unstake(&mut self， user: &str， amount: u64) -> Result<()， StakingError> {\n        let current_stake = self.stakes.get(user).ok_or(StakingError::UserNotFound)?;\n        if current_stake < &amount {\n            return Err(StakingError::InsufficientStake);\n        }\n        self.stakes.insert(user.to_string()， current_stake - amount);\n        self.total_staked -= amount;\n        Ok(())\n    }\n    \n    pub fn claim_rewards(&mut self， user: &str) -> Result<u64， StakingError> {\n        let reward = self.rewards.get(user).ok_or(StakingError::UserNotFound)?;\n        if *reward == 0 {\n            return Err(StakingError::NoRewards);\n        }\n        let reward_amount = *reward;\n        self.rewards.insert(user.to_string()， 0);\n        Ok(reward_amount)\n    }\n}", "id": 36}
{"question_type": "short_answer", "instructions": "Identify the state management vulnerability in this multi-signature wallet and refactor it to prevent race conditions and ensure atomic operations.", "contract_code": "use std::collections::HashMap;\n\npub struct MultiSigWallet {\n    owners: Vec<String>，\n    required_confirmations: u32，\n    transactions: Vec<Transaction>，\n    confirmations: HashMap<u32， Vec<String>>，\n}\n\npub struct Transaction {\n    id: u32，\n    to: String，\n    amount: u64，\n    executed: bool，\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut self， owner: &str， to: String， amount: u64) -> u32 {\n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_id，\n            to，\n            amount，\n            executed: false，\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(owner， tx_id);\n        tx_id\n    }\n    \n    pub fn confirm_transaction(&mut self， owner: &str， tx_id: u32) {\n        let confirmations = self.confirmations.entry(tx_id).or_insert(Vec::new());\n        confirmations.push(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id);\n        }\n    }\n    \n    pub fn execute_transaction(&mut self， tx_id: u32) {\n        if let Some(tx) = self.transactions.get_mut(tx_id as usize) {\n            tx.executed = true;\n            // Execute transfer logic\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_race_conditions", "points": 1, "keywords": ["race", "atomic", "state", "consistency"]}, {"criterion": "implements_atomic_operations", "points": 4, "check_function": "check_atomic_operations"}, {"criterion": "prevents_double_execution", "points": 2, "check_function": "validate_execution_safety"}], "automated_tests": ["test_double_confirmation", "test_execution_atomicity", "test_state_consistency"], "reference_solution": "use std::collections::{HashMap， HashSet};\n\n#[derive(Debug)]\npub enum WalletError {\n    UnauthorizedOwner，\n    TransactionNotFound，\n    AlreadyConfirmed，\n    AlreadyExecuted，\n    InsufficientConfirmations，\n}\n\npub struct MultiSigWallet {\n    owners: HashSet<String>，\n    required_confirmations: u32，\n    transactions: Vec<Transaction>，\n    confirmations: HashMap<u32， HashSet<String>>，\n}\n\npub struct Transaction {\n    id: u32，\n    to: String，\n    amount: u64，\n    executed: bool，\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut self， owner: &str， to: String， amount: u64) -> Result<u32， WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_id，\n            to，\n            amount，\n            executed: false，\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(owner， tx_id)?;\n        Ok(tx_id)\n    }\n    \n    pub fn confirm_transaction(&mut self， owner: &str， tx_id: u32) -> Result<()， WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx = self.transactions.get(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.entry(tx_id).or_insert(HashSet::new());\n        if confirmations.contains(owner) {\n            return Err(WalletError::AlreadyConfirmed);\n        }\n        \n        confirmations.insert(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id)?;\n        }\n        \n        Ok(())\n    }\n    \n    fn execute_transaction(&mut self， tx_id: u32) -> Result<()， WalletError> {\n        let tx = self.transactions.get_mut(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.get(&tx_id).unwrap_or(&HashSet::new());\n        if confirmations.len() < self.required_confirmations as usize {\n            return Err(WalletError::InsufficientConfirmations);\n        }\n        \n        tx.executed = true;\n        Ok(())\n    }\n}", "id": 37}
{"question_type": "code_audit", "instructions": "Identify the ownership and borrowing issues in this token transfer contract and provide corrected code that properly handles ownership semantics", "contract_code": "struct Token {\n    owner: String，\n    balance: u64，\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>，\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&self， from_idx: usize， to_owner: String) -> Result<Token， &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        transferred_token.balance = token.balance;\n        self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow_issue", "points": 3, "keywords": ["mutable", "immutable", "borrow", "self"]}, {"criterion": "fixes_ownership_semantics", "points": 2, "check_function": "check_ownership_correction"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_rust_code"}], "automated_tests": ["test_token_transfer", "test_ownership_transfer"], "reference_solution": "struct Token {\n    owner: String，\n    balance: u64，\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>，\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&mut self， from_idx: usize， to_owner: String) -> Result<Token， &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        let removed_token = self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "id": 38}
{"question_type": "short_answer", "instructions": "Analyze the lifetime and borrowing issues in this smart contract state management pattern and redesign it to properly handle references and ownership", "contract_code": "struct Account {\n    id: u32，\n    balance: u64，\n    active: bool，\n}\n\nstruct ContractState {\n    accounts: Vec<Account>，\n}\n\nimpl ContractState {\n    fn get_account_ref(&self， id: u32) -> Option<&Account> {\n        self.accounts.iter().find(|acc| acc.id == id)\n    }\n    \n    fn update_balance(&mut self， id: u32， new_balance: u64) -> Result<&Account， &'static str> {\n        let account_ref = self.get_account_ref(id);\n        if let Some(account) = account_ref {\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            let account_mut = self.accounts.iter_mut().find(|acc| acc.id == id).unwrap();\n            account_mut.balance = new_balance;\n            Ok(account_mut)\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_checker_conflict", "points": 2, "keywords": ["borrow checker", "multiple borrows", "lifetime"]}, {"criterion": "resolves_reference_lifetime_issue", "points": 4, "check_function": "check_lifetime_resolution"}, {"criterion": "code_compiles_and_functions", "points": 1, "check_function": "validate_rust_code"}], "automated_tests": ["test_account_update", "test_borrow_safety"], "reference_solution": "struct Account {\n    id: u32，\n    balance: u64，\n    active: bool，\n}\n\nstruct ContractState {\n    accounts: Vec<Account>，\n}\n\nimpl ContractState {\n    fn update_balance(&mut self， id: u32， new_balance: u64) -> Result<&Account， &'static str> {\n        let account_idx = self.accounts.iter().position(|acc| acc.id == id);\n        if let Some(idx) = account_idx {\n            let account = &mut self.accounts[idx];\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            account.balance = new_balance;\n            Ok(&self.accounts[idx])\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "id": 39}
{"question_type": "short_answer", "instructions": "Analyze the following smart contract and refactor it to implement proper trait-based modular architecture for different token types. The current implementation violates the single responsibility principle and lacks extensibility.", "contract_code": "pub struct TokenContract {\n    balances: std::collections::HashMap<String， u64>，\n    token_type: String，\n    metadata: String，\n}\n\nimpl TokenContract {\n    pub fn new(token_type: String) -> Self {\n        TokenContract {\n            balances: std::collections::HashMap::new()，\n            token_type，\n            metadata: String::new()，\n        }\n    }\n\n    pub fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        if self.token_type == \"fungible\" {\n            let balance = self.balances.get(from).unwrap_or(&0);\n            if *balance < amount {\n                return Err(\"Insufficient balance\".to_string());\n            }\n            self.balances.insert(from.to_string()， balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()， to_balance + amount);\n        } else if self.token_type == \"nft\" {\n            if amount != 1 {\n                return Err(\"NFT transfer must be exactly 1\".to_string());\n            }\n            // NFT-specific logic here\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "impl", "abstraction", "interface"]}, {"criterion": "separates_token_behaviors", "points": 2, "keywords": ["modular", "separate", "responsibility", "module"]}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_token_functionality"}, {"criterion": "follows_rust_patterns", "points": 1, "keywords": ["enum", "match", "pattern"]}], "automated_tests": ["test_fungible_transfer", "test_nft_transfer", "test_trait_implementation"], "reference_solution": "pub trait TokenBehavior {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String>;\n    fn balance_of(&self， account: &str) -> u64;\n}\n\npub struct FungibleToken {\n    balances: std::collections::HashMap<String， u64>，\n}\n\npub struct NFTToken {\n    owners: std::collections::HashMap<u64， String>，\n}\n\nimpl TokenBehavior for FungibleToken {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        if *balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balances.insert(from.to_string()， balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n    fn balance_of(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct TokenContract<T: TokenBehavior> {\n    token: T，\n    metadata: String，\n}\n\nimpl<T: TokenBehavior> TokenContract<T> {\n    pub fn new(token: T) -> Self {\n        TokenContract {\n            token，\n            metadata: String::new()，\n        }\n    }\n    pub fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        self.token.transfer(from， to， amount)\n    }\n}", "id": 40}
{"question_type": "code_audit", "instructions": "Identify the architectural flaw in this multi-contract system and refactor it to implement proper dependency injection and loose coupling between components.", "contract_code": "use std::collections::HashMap;\n\npub struct UserRegistry {\n    users: HashMap<String， User>，\n}\n\npub struct User {\n    id: String，\n    balance: u64，\n    reputation: u32，\n}\n\npub struct PaymentProcessor {\n    registry: UserRegistry，\n}\n\npub struct ReputationSystem {\n    registry: UserRegistry，\n}\n\nimpl PaymentProcessor {\n    pub fn new() -> Self {\n        PaymentProcessor {\n            registry: UserRegistry {\n                users: HashMap::new()，\n            }，\n        }\n    }\n\n    pub fn process_payment(&mut self， user_id: &str， amount: u64) -> Result<()， String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new() -> Self {\n        ReputationSystem {\n            registry: UserRegistry {\n                users: HashMap::new()，\n            }，\n        }\n    }\n\n    pub fn update_reputation(&mut self， user_id: &str， points: u32) -> Result<()， String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_tight_coupling", "points": 2, "keywords": ["coupling", "dependency", "shared", "independent"]}, {"criterion": "implements_dependency_injection", "points": 4, "keywords": ["injection", "reference", "Arc", "Rc", "shared_state"]}, {"criterion": "maintains_data_consistency", "points": 1, "check_function": "validate_shared_state_access"}], "automated_tests": ["test_shared_user_registry", "test_concurrent_access", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct UserRegistry {\n    users: HashMap<String， User>，\n}\n\npub struct User {\n    id: String，\n    balance: u64，\n    reputation: u32，\n}\n\ntype SharedRegistry = Rc<RefCell<UserRegistry>>;\n\npub struct PaymentProcessor {\n    registry: SharedRegistry，\n}\n\npub struct ReputationSystem {\n    registry: SharedRegistry，\n}\n\nimpl PaymentProcessor {\n    pub fn new(registry: SharedRegistry) -> Self {\n        PaymentProcessor { registry }\n    }\n\n    pub fn process_payment(&self， user_id: &str， amount: u64) -> Result<()， String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new(registry: SharedRegistry) -> Self {\n        ReputationSystem { registry }\n    }\n\n    pub fn update_reputation(&self， user_id: &str， points: u32) -> Result<()， String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\npub fn create_system() -> (PaymentProcessor， ReputationSystem) {\n    let registry = Rc::new(RefCell::new(UserRegistry {\n        users: HashMap::new()，\n    }));\n    \n    let payment_processor = PaymentProcessor::new(registry.clone());\n    let reputation_system = ReputationSystem::new(registry.clone());\n    \n    (payment_processor， reputation_system)\n}", "id": 41}
{"question_type": "short_answer", "instructions": "Optimize this token transfer contract to reduce memory allocations and improve gas efficiency. Focus on minimizing heap allocations and unnecessary data copies.", "contract_code": "use std::collections::HashMap;\nuse std::string::String;\n\nstruct TokenContract {\n    balances: HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl TokenContract {\n    fn transfer(&mut self， from: String， to: String， amount: u64) -> Result<()， String> {\n        let from_balance = self.balances.get(&from).unwrap_or(&0).clone();\n        let to_balance = self.balances.get(&to).unwrap_or(&0).clone();\n        \n        if from_balance < amount {\n            return Err(format!(\"Insufficient balance: {} < {}\"， from_balance， amount));\n        }\n        \n        self.balances.insert(from.clone()， from_balance - amount);\n        self.balances.insert(to.clone()， to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 3, "keywords": ["clone", "reference", "borrow"]}, {"criterion": "optimizes_string_usage", "points": 2, "keywords": ["&str", "string_slice", "reference"]}, {"criterion": "reduces_heap_allocations", "points": 2, "keywords": ["heap", "allocation", "stack"]}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_transfer_short_answer", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\n\nstruct TokenContract {\n    balances: HashMap<&'static str， u64>，\n    total_supply: u64，\n}\n\nimpl TokenContract {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， &'static str> {\n        let from_balance = *self.balances.get(from).unwrap_or(&0);\n        let to_balance = *self.balances.get(to).unwrap_or(&0);\n        \n        if from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        \n        self.balances.insert(from， from_balance - amount);\n        self.balances.insert(to， to_balance + amount);\n        Ok(())\n    }\n}", "id": 42}
{"question_type": "code_audit", "instructions": "Analyze the provided staking contract code to identify performance bottlenecks and resource management issues. Optimize the code to support batch operations， integrate yield farming mechanics， and implement slashing penalties for early withdrawals. Ensure the contract can handle high transaction volumes without resource exhaustion.", "factors_to_consider": ["Efficiency of reward calculation", "Integration of yield farming mechanics", "Implementation of slashing penalties", "Scalability for high transaction volumes", "Security against resource exhaustion"], "keywords": ["yield farming", "slashing", "batch operations", "resource management", "DeFi", "scalability"], "expected_insights": ["Identification of nested loop inefficiencies in reward calculation", "Strategies for caching or precomputing rewards to enhance performance", "Approaches to integrate yield farming and slashing mechanisms", "Methods to ensure scalability and prevent resource exhaustion"], "scoring_criteria": [{"criterion": "Identifies and optimizes nested loop inefficiencies", "points": 4, "key_points": ["Recognizes O(n^2) complexity", "Implements caching or precomputation"]}, {"criterion": "Integrates yield farming mechanics", "points": 3, "key_points": ["Implements yield farming logic", "Ensures fair reward distribution"]}, {"criterion": "Implements slashing penalties", "points": 2, "key_points": ["Correctly applies penalties", "Prevents early withdrawal abuse"]}, {"criterion": "Ensures scalability and prevents resource exhaustion", "points": 2, "key_points": ["Handles large transaction volumes", "Implements resource limits"]}], "total_possible": 11, "id": 43, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// This contract is vulnerable to performance issues with a large number of stakers.\n// The reward calculation is inefficient and can lead to out-of-gas errors.\ncontract VulnerableStaking {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public rewards;\n    address[] public stakers;\n\n    function stake() external payable {\n        require(msg.value > 0， \"Cannot stake 0\");\n        if (stakes[msg.sender] == 0) {\n            stakers.push(msg.sender);\n        }\n        stakes[msg.sender] += msg.value;\n    }\n\n    // This function is very inefficient and will consume a lot of gas with many stakers.\n    function distributeRewards() external {\n        for (uint256 i = 0; i < stakers.length; i++) {\n            address staker = stakers[i];\n            rewards[staker] += calculateReward(staker);\n        }\n    }\n\n    // A simple reward calculation function.\n    function calculateReward(address staker) internal view returns (uint256) {\n        return stakes[staker] / 100;\n    }\n\n    function withdraw() external {\n        uint256 amount = stakes[msg.sender];\n        require(amount > 0， \"No stake to withdraw\");\n        stakes[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "This smart contract has a critical bug in the withdrawal logic that only manifests under specific conditions. Write comprehensive unit tests that would catch this bug， identify the issue， and provide a corrected implementation with proper error handling.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct TokenVault {\n    balances: HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl TokenVault {\n    fn new() -> Self {\n        TokenVault {\n            balances: HashMap::new()，\n            total_supply: 0，\n        }\n    }\n    \n    fn deposit(&mut self， user: String， amount: u64) {\n        let balance = self.balances.entry(user).or_insert(0);\n        *balance += amount;\n        self.total_supply += amount;\n    }\n    \n    fn withdraw(&mut self， user: String， amount: u64) -> bool {\n        if let Some(balance) = self.balances.get_mut(&user) {\n            if *balance >= amount {\n                *balance -= amount;\n                self.total_supply -= amount;\n                return true;\n            }\n        }\n        false\n    }\n    \n    fn get_balance(&self， user: &str) -> u64 {\n        self.balances.get(user).copied().unwrap_or(0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_inconsistency", "points": 3, "keywords": ["state", "inconsistent", "total_supply", "balance"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "keywords": ["test", "assert", "edge_case"]}, {"criterion": "implements_proper_error_handling", "points": 3, "check_function": "check_error_handling_implementation"}, {"criterion": "validates_state_invariants", "points": 2, "keywords": ["invariant", "consistency", "validation"]}], "automated_tests": ["test_state_consistency", "test_edge_cases"], "reference_solution": "// Tests should reveal that total_supply can become inconsistent\n// Bug: No validation that total_supply calculation remains correct\n// Fix: Add state validation and proper error types", "id": 44}
{"question_type": "code_audit", "instructions": "Analyze this multi-signature wallet implementation for debugging and testing issues. The contract has subtle bugs that would cause failures in production. Identify the ownership and concurrency issues， then provide a corrected version with proper debug tooling and testing infrastructure.", "contract_code": "use std::sync::{Arc， Mutex};\nuse std::thread;\n\n#[derive(Debug， Clone)]\nstruct MultiSigWallet {\n    owners: Vec<String>，\n    required_signatures: usize，\n    pending_transactions: Arc<Mutex<Vec<Transaction>>>，\n}\n\n#[derive(Debug， Clone)]\nstruct Transaction {\n    id: u64，\n    to: String，\n    amount: u64，\n    signatures: Vec<String>，\n    executed: bool，\n}\n\nimpl MultiSigWallet {\n    fn new(owners: Vec<String>， required_sigs: usize) -> Self {\n        MultiSigWallet {\n            owners，\n            required_signatures: required_sigs，\n            pending_transactions: Arc::new(Mutex::new(Vec::new()))，\n        }\n    }\n    \n    fn sign_transaction(&self， tx_id: u64， signer: String) -> bool {\n        let mut transactions = self.pending_transactions.lock().unwrap();\n        for tx in transactions.iter_mut() {\n            if tx.id == tx_id && !tx.executed {\n                tx.signatures.push(signer);\n                if tx.signatures.len() >= self.required_signatures {\n                    tx.executed = true;\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_debugging_issues", "points": 2, "keywords": ["debug", "logging", "error_handling", "mutex"]}, {"criterion": "fixes_concurrency_bugs", "points": 4, "keywords": ["concurrency", "race_condition", "lock", "thread_safety"]}, {"criterion": "implements_testing_framework", "points": 1, "check_function": "validate_test_infrastructure"}, {"criterion": "adds_proper_validation", "points": 3, "keywords": ["validation", "duplicate", "owner_check"]}], "automated_tests": ["test_concurrent_signing", "test_duplicate_signatures"], "reference_solution": "// Issues: No duplicate signature prevention， no owner validation， poor error handling\n// Fix: Add owner validation， prevent duplicate signatures， implement proper Result types", "id": 45}
{"question_type": "code_audit", "instructions": "Examine the provided smart contract code for vulnerabilities related to interface exposure and unauthorized access. Propose a secure implementation that restricts access to the vault contract， ensuring only authorized transactions are processed. Your solution should maintain the integrity of the interface design and adhere to best practices in Web3 security.", "factors_to_consider": ["Access control mechanisms", "Interface encapsulation", "Authorization checks", "Compliance with Web3 security standards"], "keywords": ["access control", "interface encapsulation", "authorization", "Web3 security", "smart contract audit"], "expected_insights": ["Identification of direct interface exposure risks", "Implementation of robust access control measures", "Understanding of Web3-specific security practices", "Ability to maintain interface integrity while enhancing security"], "scoring_criteria": [{"criterion": "Identifies interface exposure", "points": 3, "key_points": ["Recognizes direct access to the vault", "Understands risks of interface exposure"]}, {"criterion": "Implements proper access control", "points": 4, "key_points": ["Applies authorization checks", "Prevents unauthorized transactions"]}, {"criterion": "Maintains interface design", "points": 2, "key_points": ["Preserves original interface structure", "Ensures compatibility with existing contracts"]}, {"criterion": "Adheres to Web3 security standards", "points": 3, "key_points": ["Follows best practices in smart contract security", "Demonstrates understanding of decentralized systems"]}], "total_possible": 12, "id": 46, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// An interface for a simple vault.\ninterface IVault {\n    function withdraw(uint256 amount) external;\n}\n\n// A vault contract that is vulnerable to unauthorized access.\n// The owner of the vault is not properly checked.\ncontract VulnerableVault is IVault {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint256 amount) external override {\n        // This check is insufficient because it does not verify the caller.\n        require(address(this).balance >= amount， \"Insufficient balance\");\n        payable(msg.sender).transfer(amount);\n    }\n\n    receive() external payable {}\n}\n\n// A contract that interacts with the vault.\n// It exposes the vault interface directly， allowing anyone to call it.\ncontract VaultInteractor {\n    IVault public vault;\n\n    constructor(address _vaultAddress) {\n        vault = IVault(_vaultAddress);\n    }\n\n    // This function allows anyone to withdraw from the vault.\n    function doWithdraw(uint256 amount) public {\n        vault.withdraw(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Refactor this cross-contract communication system to implement proper error handling and eliminate panic conditions while maintaining interface compatibility across contract boundaries", "contract_code": "pub trait TokenInterface {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String>;\n    fn mint(&mut self， to: &str， amount: u64) -> Result<()， String>;\n    fn burn(&mut self， from: &str， amount: u64) -> Result<()， String>;\n    fn balance_of(&self， account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        let from_balance = self.balances.get(from).ok_or_else(|| \"Source account not found\".to_string())?;\n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n\n        self.balances.insert(from.to_string()， from_balance - amount);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n\n    fn mint(&mut self， to: &str， amount: u64) -> Result<()， String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()， balance + amount);\n        self.total_supply += amount;\n        Ok(())\n    }\n\n    fn burn(&mut self， from: &str， amount: u64) -> Result<()， String> {\n        let balance = self.balances.get(from).ok_or_else(|| \"Account not found\".to_string())?;\n        if balance < &amount {\n            return Err(\"Insufficient funds to burn\".to_string());\n        }\n        self.balances.insert(from.to_string()， balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n\n    fn balance_of(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_conditions", "points": 2, "keywords": ["panic", "unwrap", "assert", "error handling"]}, {"criterion": "implements_result_based_interface", "points": 2, "check_function": "check_result_type_usage"}, {"criterion": "maintains_interface_compatibility", "points": 3, "check_function": "validate_interface_compatibility"}], "automated_tests": ["test_error_propagation", "test_interface_compatibility"], "reference_solution": "pub trait TokenInterface {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String>;\n    fn mint(&mut self， to: &str， amount: u64) -> Result<()， String>;\n    fn burn(&mut self， from: &str， amount: u64) -> Result<()， String>;\n    fn balance_of(&self， account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<()， String> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        \n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        \n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(from.to_string()， from_balance - amount);\n        self.balances.insert(to.to_string()， to_balance + amount);\n        Ok(())\n    }\n    \n    fn mint(&mut self， to: &str， amount: u64) -> Result<()， String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        \n        if let Some(new_balance) = balance.checked_add(amount) {\n            self.balances.insert(to.to_string()， new_balance);\n            self.total_supply = self.total_supply.checked_add(amount)\n                .ok_or(\"Total supply overflow\")?;\n            Ok(())\n        } else {\n            Err(\"Balance overflow\".to_string())\n        }\n    }\n    \n    fn burn(&mut self， from: &str， amount: u64) -> Result<()， String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        \n        if balance < &amount {\n            return Err(\"Insufficient balance to burn\".to_string());\n        }\n        \n        self.balances.insert(from.to_string()， balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n    \n    fn balance_of(&self， account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct DeFiProtocol {\n    token: Token，\n}\n\nimpl DeFiProtocol {\n    pub fn swap_tokens(&mut self， user: &str， amount: u64) -> Result<()， String> {\n        self.token.burn(user， amount)?;\n        self.token.mint(user， amount * 2)?;\n        Ok(())\n    }\n}", "id": 47}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks", "contract_code": "struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl Token {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()， from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()， to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_safe_arithmetic_operations"}, {"criterion": "maintains_contract_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_prevention", "test_normal_transfer"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<String， u64>，\n    total_supply: u64，\n}\n\nimpl Token {\n    fn transfer(&mut self， from: &str， to: &str， amount: u64) -> Result<bool， &'static str> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()， from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()， new_balance);\n                    Ok(true)\n                }\n                None => Err(\"Arithmetic overflow prevented\")\n            }\n        } else {\n            Ok(false)\n        }\n    }\n}", "id": 48}
{"question_type": "code_audit", "instructions": "Analyze this smart contract for reentrancy vulnerabilities and implement proper state management to prevent reentrancy attacks", "contract_code": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<String， u64>，\n    total_deposits: u64，\n}\n\nimpl Vault {\n    fn withdraw(&mut self， user: &str， amount: u64) -> Result<()， &'static str> {\n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // External call simulation\n            self.external_transfer(user， amount)?;\n            \n            // State update after external call\n            self.balances.insert(user.to_string()， balance - amount);\n            self.total_deposits -= amount;\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&self， _user: &str， _amount: u64) -> Result<()， &'static str> {\n        // Simulates external contract call\n        Ok(())\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_reentrancy_pattern", "points": 2, "keywords": ["reentrancy", "state", "external", "call"]}, {"criterion": "implements_checks_effects_interactions", "points": 2, "check_function": "check_state_update_order"}, {"criterion": "adds_reentrancy_guard", "points": 3, "check_function": "validate_reentrancy_protection"}], "automated_tests": ["test_reentrancy_prevention", "test_state_consistency"], "reference_solution": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<String， u64>，\n    total_deposits: u64，\n    locked: bool，\n}\n\nimpl Vault {\n    fn withdraw(&mut self， user: &str， amount: u64) -> Result<()， &'static str> {\n        if self.locked {\n            return Err(\"Reentrant call detected\");\n        }\n        \n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // Update state before external call\n            self.balances.insert(user.to_string()， balance - amount);\n            self.total_deposits -= amount;\n            \n            // Set reentrancy guard\n            self.locked = true;\n            let result = self.external_transfer(user， amount);\n            self.locked = false;\n            \n            result\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&self， _user: &str， _amount: u64) -> Result<()， &'static str> {\n        Ok(())\n    }\n}", "id": 49}
