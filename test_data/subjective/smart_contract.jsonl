{"question_type": "code_audit", "title": "Solidity Re-entrancy (basic vault)", "instructions": "Identify the vulnerability and provide fixed code.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract VulnerableBank {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(balances[msg.sender] >= amountï¼Œ \"Insufficient balance\");\n        (bool successï¼Œ ) = msg.sender.call{value: amount}(\"\");\n        require(successï¼Œ \"Transfer failed\");\n        balances[msg.sender] -= amount;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "reentrant"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw_workflow", "test_reentrancy_attack_prevention"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureBank is ReentrancyGuard {\n    mapping(address => uint256) public balances;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdraw(uint256 amount) external nonReentrant {\n        require(balances[msg.sender] >= amountï¼Œ \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        (bool successï¼Œ ) = msg.sender.call{value: amount}(\"\");\n        require(successï¼Œ \"Transfer failed\");\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "ERC-777 / ERC-20 Callback Re-entrancy", "instructions": "Locate the vulnerability in the vault and supply a patched version.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract VulnerableVault is IERC777Recipient {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    // ERC-777 hook fires before balance update â†’ re-entrancy window\n    function tokensReceived(\n        addressï¼Œ address fromï¼Œ addressï¼Œ uint256 amountï¼Œ\n        bytes calldataï¼Œ bytes calldata\n    ) external override {\n        deposits[from] += amount;\n    }\n\n    function withdraw(uint256 amt) external {\n        require(deposits[msg.sender] >= amtï¼Œ \"not enough\");\n        token.transfer(msg.senderï¼Œ amt);     // external call first â‡’ re-entrancy\n        deposits[msg.sender] -= amt;\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["reentrancy", "callback"]}, {"criterion": "follows_checks_effects_interactions", "points": 3, "check_function": "check_state_update_before_external_call"}, {"criterion": "implements_reentrancy_guard", "points": 2, "check_function": "check_reentrancy_guard"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_deposit_withdraw", "test_callback_reentrancy"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/token/ERC777/IERC777Recipient.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ncontract SecureVault is IERC777Recipientï¼Œ ReentrancyGuard {\n    IERC20 public immutable token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) { token = IERC20(_token); }\n\n    function tokensReceived(\n        addressï¼Œ address fromï¼Œ addressï¼Œ uint256 amountï¼Œ\n        bytes calldataï¼Œ bytes calldata\n    ) external override {\n        deposits[from] += amount;           // state change first\n    }\n\n    function withdraw(uint256 amt) external nonReentrant {\n        require(deposits[msg.sender] >= amtï¼Œ \"not enough\");\n        deposits[msg.sender] -= amt;        // Effects\n        require(token.transfer(msg.senderï¼Œ amt)ï¼Œ \"transfer failed\"); // Interaction\n    }\n}", "total_possible": 8}
{"question_type": "code_audit", "title": "Predictable On-Chain Randomness", "instructions": "Explain why the randomness is predictable and provide a secure alternative.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract PredictableLottery {\n    function draw() external view returns (uint256) {\n        return uint256(\n            keccak256(abi.encodePacked(blockhash(block.number - 1)ï¼Œ block.timestamp))\n        ) % 100; // miner-controlled input\n    }\n}", "vulnerability_type": "predictable_randomness", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["predictable", "randomness"]}, {"criterion": "implements_vrf_or_commit_reveal", "points": 3, "check_function": "check_secure_randomness"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_unpredictable_draw"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@chainlink/contracts/src/v0.8/VRFConsumerBase.sol\";\n\ncontract VRFLottery is VRFConsumerBase { /* VRF wiring omitted */ }", "total_possible": 6}
{"question_type": "code_audit", "title": "Rent-Exempt Bypass (Solana)", "instructions": "Demonstrate how a rent exemption bypass can be exploited in Solana account management and propose a solution. Your solution should include a code fix and the implementation of a validation check to prevent further exploitation of this vulnerability.", "contract_code": "// Attacker tops up lamports to appear rent-exemptï¼Œ then withdraws in the same slotï¼Œ bypassing the rent exemption check.", "vulnerability_type": "rent_exemption_spoof", "scoring_criteria": [{"criterion": "Identifies the Vulnerability Type", "points": 2, "keywords": ["rent", "exempt", "spoof"], "description": "The student must correctly identify the rent exemption spoof vulnerability in the provided contract codeï¼Œ demonstrating understanding of how attackers manipulate rent exemption status."}, {"criterion": "Adds Post-Instruction Check", "points": 3, "check_function": "check_rent_after_ops", "description": "The student must implement a validation check after critical operations to ensure that the account still meets the rent exemption criteria. This is done by calling sysvar::rent::check_reserve(&account) after every transfer."}, {"criterion": "Fix Implementation", "points": 4, "description": "The student should provide a code fix that prevents rent exemption spoofing. The solution must include a reliable check for rent exemption after the transaction and before any withdrawals can happen."}], "automated_tests": ["test_rent_exempt_validation", "test_account_rent_check_post_transaction"], "reference_solution": "// Code Fix: After all transfersï¼Œ validate the rent exemption status by invoking sysvar::rent::check_reserve(&account). If the account does not meet the rent exemption criteriaï¼Œ the transaction should fail.\n\nfn check_rent_after_ops(account: &Account) -> Result<()ï¼Œ &'static str> {\n  if !sysvar::rent::check_reserve(account) {\n    return Err(\"Account does not meet rent exemption criteria\");\n  }\n  Ok(())\n}", "total_possible": 9}
{"question_type": "code_audit", "title": "CosmWasm BankMsg Unlimited Send", "instructions": "Spot the unbounded token forward and cap the loss.", "contract_code": "// CosmWasm 1.3\npub fn execute_forward(\n    _deps: DepsMutï¼Œ\n    _info: MessageInfoï¼Œ\n    to: Stringï¼Œ\n    amount: Coinï¼Œ\n) -> Result<Responseï¼Œ StdError> {\n    let msg = cosmwasm_std::BankMsg::Send {\n        to_address: toï¼Œ\n        amount: vec![amount]ï¼Œ\n    }; // no upper limit or ACL\n    Ok(Response::new().add_message(msg))\n}", "vulnerability_type": "unbounded_transfer", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["unlimited", "drain"]}, {"criterion": "adds_amount_cap_or_acl", "points": 3, "check_function": "check_amount_limit"}], "automated_tests": ["test_max_transfer_cap"], "reference_solution": "Assert amount â‰¤ MAX_CAP and require sender is whitelisted before forwarding.", "total_possible": 5}
{"question_type": "code_audit", "title": "IBC Light-Client Verification Flaw", "instructions": "Describe the proof-height bug and harden the check.", "contract_code": "// Cosmos SDK 0.47\nif !client.verify_membership(storeï¼Œ proofï¼Œ proof_heightï¼Œ ...) {\n    // should compare with trusted_height but does not\n}", "vulnerability_type": "light_client_height_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["proof-height"]}, {"criterion": "enforces_monotonic_height", "points": 3, "check_function": "check_height_validation"}], "automated_tests": ["test_forged_packet_blocked"], "reference_solution": "Require proof_height â‰¥ consensus_state.latest_height and â‰¤ trusted_height; prune expired consensus states.", "total_possible": 5}
{"question_type": "code_audit", "title": "MPC Threshold Signature Bypass", "instructions": "Analyse how inconsistent curve parameters break the threshold guarantee and lock them down.", "contract_code": "// Rust (simplified)\nstruct Share { curve_id: Option<u8>ï¼Œ r: Scalarï¼Œ s: Scalar }\n// Coordinator never verifies that all shares use the same curve_id", "vulnerability_type": "threshold_bypass", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["threshold", "bypass"]}, {"criterion": "binds_curve_params", "points": 3, "check_function": "check_curve_id"}], "automated_tests": ["test_threshold_enforcement"], "reference_solution": "Add curve domain separator to every share transcript and reject aggregation if any curve_id mismatches.", "total_possible": 5}
{"question_type": "code_audit", "title": "Solidity Unrestricted Self-Destruct", "instructions": "Show how anyone can destroy the contract and fix the access control.", "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract BoomBox {\n    function boom(address payable receiver) external {\n        selfdestruct(receiver); // ðŸ”¥ unrestricted\n    }\n    receive() external payable {}\n}", "vulnerability_type": "unrestricted_selfdestruct", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["selfdestruct", "access"]}, {"criterion": "locks_down_or_removes_selfdestruct", "points": 3, "check_function": "check_only_owner"}, {"criterion": "code_compiles", "points": 1, "check_function": "validate_solidity_code"}], "automated_tests": ["test_selfdestruct_protection"], "reference_solution": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\ncontract SafeBox {\n    address public immutable owner = msg.sender;\n    modifier onlyOwner { require(msg.sender == ownerï¼Œ \"not owner\"); _; }\n\n    function destroy(address payable receiver) external onlyOwner {\n        selfdestruct(receiver);\n    }\n    receive() external payable {}\n}", "total_possible": 6}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract for security vulnerabilities related to the use of delegatecall. Explain the risks associated with arbitrary delegatecall and propose a secure solution that restricts the callee to a trusted implementation. Consider using established patterns and libraries to enhance security.", "factors_to_consider": ["The risk of arbitrary delegatecall allowing unauthorized code execution", "The importance of restricting the implementation address to a trusted source", "The use of established proxy patterns and libraries like OpenZeppelin", "Gas efficiency and execution cost implications", "Potential edge cases and attack vectors specific to delegatecall"], "keywords": ["delegatecall", "proxy pattern", "OpenZeppelin", "trusted implementation", "smart contract security", "Solidity"], "expected_insights": ["Understanding of delegatecall risks and how they can lead to unauthorized state changes", "Knowledge of how to restrict the implementation address to prevent arbitrary delegatecall", "Familiarity with using OpenZeppelin's proxy contracts to enhance security", "Ability to identify and mitigate potential attack vectors in smart contract design"], "scoring_criteria": [{"criterion": "identifies_delegatecall_issue", "points": 2, "key_points": ["Recognizes the security risk of arbitrary delegatecall", "Explains potential consequences of the vulnerability"]}, {"criterion": "restricts_implementation_address", "points": 3, "key_points": ["Proposes a method to restrict the implementation address to a trusted source", "Demonstrates understanding of access control mechanisms"]}, {"criterion": "uses_secure_proxy_pattern", "points": 2, "key_points": ["Recommends using OpenZeppelin's proxy pattern", "Explains the benefits of using established libraries"]}], "total_possible": 7, "id": 9, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// A contract that can be used as a library for the main contract.\ncontract LibraryContract {\n    uint256 public value;\n\n    function setValue(uint256 _value) public {\n        value = _value;\n    }\n}\n\n// The main contract that uses delegatecall to call the library.\n// This contract is vulnerable because the library address can be changed by anyone.\ncontract VulnerableProxy {\n    address public implementation;\n    address public owner;\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n        owner = msg.sender;\n    }\n\n    // The attacker can change the implementation address to a malicious contract.\n    function setImplementation(address _newImplementation) public {\n        implementation = _newImplementation;\n    }\n\n    // The fallback function that delegates calls to the implementation contract.\n    fallback() external payable {\n        (bool successï¼Œ bytes memory data) = implementation.delegatecall(msg.data);\n        require(successï¼Œ \"Delegatecall failed\");\n    }\n}\n"}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify vulnerabilities related to ECDSA signature malleability. Demonstrate how an attacker could exploit the 's' value malleability to reuse permits. Implement a solution that enforces EIP-2 compliance by ensuring the 's' value is in the lower half of the secp256k1 curve and properly manages nonces to prevent replay attacks. Provide a detailed explanation of your approach and the security implications.", "factors_to_consider": ["ECDSA signature malleability", "EIP-2 compliance for 's' value", "Nonce management to prevent replay attacks", "Security implications of signature reuse", "Compatibility with existing ERC20 standards"], "keywords": ["ECDSA", "signature malleability", "EIP-2", "nonce management", "replay attack", "Solidity", "ERC20"], "expected_insights": ["Understanding of ECDSA signature structure and vulnerabilities", "Knowledge of EIP-2 and its importance in preventing malleability", "Ability to implement nonce management to enhance security", "Insight into how signature malleability can be exploited in smart contracts", "Technical proficiency in Solidity for implementing secure contracts"], "scoring_criteria": [{"criterion": "Identifies signature malleability vulnerability", "points": 2, "key_points": ["Correctly identifies the 's' value malleability issue", "Explains potential exploits using signature reuse"]}, {"criterion": "Implements EIP-2 compliance", "points": 3, "key_points": ["Ensures 's' value is in the lower half of the curve", "Explains the significance of EIP-2 compliance"]}, {"criterion": "Manages nonces effectively", "points": 2, "key_points": ["Implements nonce incrementation on successful permit", "Prevents replay attacks through nonce checks"]}, {"criterion": "Code compiles and functions correctly", "points": 1, "key_points": ["Code compiles without errors", "Passes provided automated tests"]}], "total_possible": 8, "id": 10, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n// This contract is vulnerable to ECDSA signature malleability.\n// An attacker can submit a valid signature with a different `s` value.\ncontract VulnerableSignatureValidator {\n    address public signer;\n\n    constructor(address _signer) {\n        signer = _signer;\n    }\n\n    // This function is vulnerable because it does not check for a unique `s` value.\n    function isValidSignature(bytes32 messageï¼Œ bytes memory signature) public view returns (bool) {\n        return ECDSA.recover(messageï¼Œ signature) == signer;\n    }\n\n    // An attacker can use this function to replay a valid signature with a modified `s` value.\n    function execute(bytes32 messageï¼Œ bytes memory signature) public {\n        require(isValidSignature(messageï¼Œ signature)ï¼Œ \"Invalid signature\");\n        // Execute some action...\n    }\n}\n"}
{"question_type": "code_audit", "title": "Cairo Dictionary Key Collision", "instructions": "Identify the dictionary seed collision and propose deterministic namespacing.", "contract_code": "# Cairo 1.1\n@storage_var\ndef balances(key: felt) -> felt:\n    pass\n\n@external\ndef deposit{syscall_ptr: felt*ï¼Œ pedersen_ptr: HashBuiltin*ï¼Œ range_check_ptr}(user: feltï¼Œ amount: felt):\n    balances.write(userï¼Œ balances.read(user) + amount)\n\n# Multiple contracts deploying this code will share the same storage path for identical keys", "vulnerability_type": "storage_key_collision", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["collision", "storage", "dictionary"]}, {"criterion": "adds_contract_address_to_seed", "points": 3, "check_function": "check_unique_seed"}], "automated_tests": ["test_no_storage_overlap"], "reference_solution": "@storage_var\ndef balances(contract_address: feltï¼Œ key: felt) -> felt: pass  # include deployer address", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Analyze the provided Solidity contract to identify potential vulnerabilities related to gas stipend limitations when using transfer(). Refactor the contract to use a safer ETH transfer patternï¼Œ such as call()ï¼Œ ensuring the contract remains secure and functional. Provide a detailed explanation of the changes made and why they address the identified issues.", "factors_to_consider": ["Impact of EIP-1884 on gas costs", "Differences between transfer()ï¼Œ send()ï¼Œ and call()", "Security implications of using call()", "Ensuring reentrancy safety"], "keywords": ["EIP-1884", "gas stipend", "transfer()", "call()", "reentrancy"], "expected_insights": ["Understanding of gas stipend limitations post-EIP-1884", "Ability to refactor code to use call() safely", "Knowledge of reentrancy vulnerabilities and prevention techniques"], "scoring_criteria": [{"criterion": "Identifies gas stipend vulnerability", "points": 2, "key_points": ["Mentions EIP-1884 impact", "Explains why transfer() can fail"]}, {"criterion": "Refactors to safe ETH transfer pattern", "points": 3, "key_points": ["Uses call() with proper checks", "Ensures reentrancy safety"]}, {"criterion": "Code compiles successfully", "points": 1, "key_points": ["No syntax errors", "Compiles with Solidity 0.8.22"]}], "total_possible": 6, "id": 12}
{"question_type": "code_audit", "title": "NEAR Promise Callback Re-entrancy", "instructions": "Demonstrate the re-entrancy window in the callback and defend against it.", "contract_code": "// Rust â€“ NEAR\n#[near_bindgen]\nimpl Contract {\n    #[payable]\n    pub fn lock(&mut self) {\n        let amount = env::attached_deposit();\n        Promise::new(self.vault.clone()).transfer(amount).then(\n            Promise::new(env::current_account_id()).function_call(\n                \"release\".to_string()ï¼Œ\n                vec![]ï¼Œ 0ï¼Œ Gas(50_000_000_000_000)\n            )\n        ); // state not updated until after the external transfer\n    }\n\n    pub fn release(&mut self) {\n        self.unlocked = true; // attacker re-enters before lock state set\n    }\n}", "vulnerability_type": "promise_reentrancy", "scoring_criteria": [{"criterion": "identifies_vulnerability_type", "points": 2, "keywords": ["promise", "reentrancy"]}, {"criterion": "moves_state_update_before_promise", "points": 3, "check_function": "check_effects_first"}], "automated_tests": ["test_promise_reentrancy_guard"], "reference_solution": "Set self.locked = true before issuing the Promise and require(!locked) in entry functions.", "total_possible": 5}
{"question_type": "code_audit", "instructions": "Identify the ownership issue in this token transfer contract and provide fixed code that properly handles mutable borrowing", "contract_code": "struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n}\n\nimpl Token {\n    fn transfer(&selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow", "points": 2, "keywords": ["immutable", "mutable", "self", "borrow"]}, {"criterion": "fixes_method_signature", "points": 3, "check_function": "check_mutable_self_correction"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_token_transfer"}], "automated_tests": ["test_token_transfer", "test_insufficient_balance"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n}\n\nimpl Token {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ &'static str> {\n        let from_balance = self.balances.get(from).ok_or(\"Account not found\")?;\n        if *from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n}", "id": 14}
{"question_type": "short_answer", "instructions": "Complete the smart contract voting system by implementing proper ownership patterns for vote delegation while avoiding move semantics issues", "contract_code": "struct Vote {\n    proposal_id: u32ï¼Œ\n    voter: Stringï¼Œ\n    weight: u32ï¼Œ\n}\n\nstruct VotingSystem {\n    votes: Vec<Vote>ï¼Œ\n    delegates: std::collections::HashMap<Stringï¼Œ String>ï¼Œ\n}\n\nimpl VotingSystem {\n    fn delegate_vote(&mut selfï¼Œ delegator: Stringï¼Œ delegate: String) {\n        self.delegates.insert(delegatorï¼Œ delegate);\n    }\n    \n    fn cast_vote(&mut selfï¼Œ vote: Vote) {\n        let effective_voter = self.get_effective_voter(vote.voter);\n        let delegated_vote = Vote {\n            proposal_id: vote.proposal_idï¼Œ\n            voter: effective_voterï¼Œ\n            weight: vote.weightï¼Œ\n        };\n        self.votes.push(delegated_vote);\n    }\n    \n    fn get_effective_voter(&selfï¼Œ voter: String) -> String {\n        // TODO: Implement without ownership issues\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "implements_borrow_pattern", "points": 3, "keywords": ["borrow", "reference", "clone", "lifetime"]}, {"criterion": "avoids_move_semantics", "points": 2, "check_function": "check_no_unnecessary_moves"}, {"criterion": "handles_delegation_chain", "points": 2, "check_function": "validate_delegation_logic"}], "automated_tests": ["test_vote_delegation", "test_delegation_chain"], "reference_solution": "fn get_effective_voter(&selfï¼Œ voter: String) -> String {\n    match self.delegates.get(&voter) {\n        Some(delegate) => delegate.clone()ï¼Œ\n        None => voterï¼Œ\n    }\n}", "id": 15}
{"question_type": "short_answer", "instructions": "Optimize this asset management contract to eliminate unnecessary cloning and improve borrowing patterns for better performance", "contract_code": "struct Asset {\n    id: Stringï¼Œ\n    owner: Stringï¼Œ\n    metadata: std::collections::HashMap<Stringï¼Œ String>ï¼Œ\n}\n\nstruct AssetRegistry {\n    assets: std::collections::HashMap<Stringï¼Œ Asset>ï¼Œ\n}\n\nimpl AssetRegistry {\n    fn transfer_asset(&mut selfï¼Œ asset_id: Stringï¼Œ new_owner: String) -> Result<()ï¼Œ &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset.clone();\n        updated_asset.owner = new_owner;\n        self.assets.insert(asset_idï¼Œ updated_asset);\n        Ok(())\n    }\n    \n    fn get_asset_owner(&selfï¼Œ asset_id: String) -> Option<String> {\n        self.assets.get(&asset_id).map(|asset| asset.owner.clone())\n    }\n    \n    fn update_metadata(&mut selfï¼Œ asset_id: Stringï¼Œ key: Stringï¼Œ value: String) -> Result<()ï¼Œ &'static str> {\n        let asset = self.assets.get(&asset_id).ok_or(\"Asset not found\")?.clone();\n        let mut updated_asset = asset;\n        updated_asset.metadata.insert(keyï¼Œ value);\n        self.assets.insert(asset_idï¼Œ updated_asset);\n        Ok(())\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 1, "keywords": ["clone", "unnecessary", "reference"]}, {"criterion": "optimizes_mutable_access", "points": 4, "check_function": "check_direct_mutation"}, {"criterion": "improves_string_handling", "points": 2, "check_function": "validate_string_borrowing"}], "automated_tests": ["test_asset_transfer", "test_metadata_update"], "reference_solution": "impl AssetRegistry {\n    fn transfer_asset(&mut selfï¼Œ asset_id: &strï¼Œ new_owner: String) -> Result<()ï¼Œ &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.owner = new_owner;\n        Ok(())\n    }\n    \n    fn get_asset_owner(&selfï¼Œ asset_id: &str) -> Option<&str> {\n        self.assets.get(asset_id).map(|asset| asset.owner.as_str())\n    }\n    \n    fn update_metadata(&mut selfï¼Œ asset_id: &strï¼Œ key: Stringï¼Œ value: String) -> Result<()ï¼Œ &'static str> {\n        self.assets.get_mut(asset_id).ok_or(\"Asset not found\")?.metadata.insert(keyï¼Œ value);\n        Ok(())\n    }\n}", "id": 16}
{"question_type": "short_answer", "instructions": "Debug the failing test cases for this escrow contract by identifying and fixing the borrowing conflicts that prevent compilation", "contract_code": "struct Escrow {\n    funds: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    pending_releases: Vec<String>ï¼Œ\n}\n\nimpl Escrow {\n    fn deposit(&mut selfï¼Œ account: Stringï¼Œ amount: u64) {\n        let balance = self.funds.entry(account.clone()).or_insert(0);\n        *balance += amount;\n        self.pending_releases.push(account);\n    }\n    \n    fn release_funds(&mut selfï¼Œ account: &str) -> Result<u64ï¼Œ &'static str> {\n        let funds = self.funds.get(account).ok_or(\"No funds found\")?;\n        let amount = *funds;\n        self.funds.remove(account);\n        self.pending_releases.retain(|acc| acc != account);\n        Ok(amount)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_escrow_operations() {\n        let mut escrow = Escrow {\n            funds: std::collections::HashMap::new()ï¼Œ\n            pending_releases: Vec::new()ï¼Œ\n        };\n        \n        escrow.deposit(\"alice\".to_string()ï¼Œ 100);\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        let pending = &escrow.pending_releases;\n        assert_eq!(*balanceï¼Œ 100);\n        assert!(pending.contains(&\"alice\".to_string()));\n        \n        let released = escrow.release_funds(\"alice\").unwrap();\n        assert_eq!(releasedï¼Œ 100);\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_conflict", "points": 2, "keywords": ["borrow", "conflict", "immutable", "mutable"]}, {"criterion": "fixes_test_borrowing", "points": 2, "check_function": "check_test_compilation"}, {"criterion": "maintains_test_logic", "points": 3, "check_function": "validate_test_assertions"}], "automated_tests": ["test_escrow_operations", "test_multiple_deposits"], "reference_solution": "#[test]\nfn test_escrow_operations() {\n    let mut escrow = Escrow {\n        funds: std::collections::HashMap::new()ï¼Œ\n        pending_releases: Vec::new()ï¼Œ\n    };\n    \n    escrow.deposit(\"alice\".to_string()ï¼Œ 100);\n    {\n        let balance = escrow.funds.get(\"alice\").unwrap();\n        assert_eq!(*balanceï¼Œ 100);\n    }\n    assert!(escrow.pending_releases.contains(&\"alice\".to_string()));\n    \n    let released = escrow.release_funds(\"alice\").unwrap();\n    assert_eq!(releasedï¼Œ 100);\n}", "id": 17}
{"question_type": "short_answer", "instructions": "Refactor this monolithic smart contract into a modular architecture using the Strategy pattern for different token distribution mechanisms. Implement proper trait abstractions and demonstrate how to swap distribution strategies at runtime.", "contract_code": "struct TokenDistributor {\n    balance: u64ï¼Œ\n    distribution_type: Stringï¼Œ\n}\n\nimpl TokenDistributor {\n    fn distribute(&mut selfï¼Œ amount: u64ï¼Œ recipients: Vec<String>) -> Result<()ï¼Œ String> {\n        if self.distribution_type == \"equal\" {\n            let per_recipient = amount / recipients.len() as u64;\n            self.balance -= amount;\n            println!(\"Equal distribution: {} per recipient\"ï¼Œ per_recipient);\n        } else if self.distribution_type == \"weighted\" {\n            // Hardcoded weighted logic\n            self.balance -= amount;\n            println!(\"Weighted distribution\");\n        } else if self.distribution_type == \"lottery\" {\n            // Hardcoded lottery logic\n            self.balance -= amount;\n            println!(\"Lottery distribution\");\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "strategy", "abstraction"]}, {"criterion": "demonstrates_modular_architecture", "points": 2, "keywords": ["modular", "separation", "decoupled"]}, {"criterion": "enables_runtime_strategy_swapping", "points": 2, "check_function": "check_strategy_swapping"}], "automated_tests": ["test_strategy_pattern", "test_runtime_swapping"], "reference_solution": "trait DistributionStrategy {\n    fn distribute(&selfï¼Œ amount: u64ï¼Œ recipients: &[String]) -> Result<()ï¼Œ String>;\n}\n\nstruct EqualDistribution;\nstruct WeightedDistribution;\nstruct LotteryDistribution;\n\nimpl DistributionStrategy for EqualDistribution {\n    fn distribute(&selfï¼Œ amount: u64ï¼Œ recipients: &[String]) -> Result<()ï¼Œ String> {\n        let per_recipient = amount / recipients.len() as u64;\n        println!(\"Equal: {} per recipient\"ï¼Œ per_recipient);\n        Ok(())\n    }\n}\n\nstruct TokenDistributor {\n    balance: u64ï¼Œ\n    strategy: Box<dyn DistributionStrategy>ï¼Œ\n}\n\nimpl TokenDistributor {\n    fn set_strategy(&mut selfï¼Œ strategy: Box<dyn DistributionStrategy>) {\n        self.strategy = strategy;\n    }\n    \n    fn distribute(&mut selfï¼Œ amount: u64ï¼Œ recipients: Vec<String>) -> Result<()ï¼Œ String> {\n        if self.balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balance -= amount;\n        self.strategy.distribute(amountï¼Œ &recipients)\n    }\n}", "id": 18}
{"question_type": "code_audit", "instructions": "This contract attempts to implement a Factory pattern for creating different types of accountsï¼Œ but has critical ownership and lifetime issues. Identify the problems and provide a corrected implementation that properly manages object lifetimes and ownership.", "contract_code": "struct Account {\n    id: u32ï¼Œ\n    balance: u64ï¼Œ\n    account_type: Stringï¼Œ\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<&Account>ï¼Œ\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn create_account(&mut selfï¼Œ id: u32ï¼Œ account_type: String) -> &Account {\n        let account = Account {\n            idï¼Œ\n            balance: 0ï¼Œ\n            account_typeï¼Œ\n        };\n        self.created_accounts.push(&account);\n        &account\n    }\n    \n    fn get_account(&selfï¼Œ id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id).copied()\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_lifetime_issues", "points": 2, "keywords": ["lifetime", "dangling", "reference"]}, {"criterion": "fixes_ownership_model", "points": 4, "check_function": "check_ownership_fix"}, {"criterion": "maintains_factory_pattern", "points": 1, "keywords": ["factory", "pattern"]}], "automated_tests": ["test_factory_creation", "test_account_retrieval"], "reference_solution": "struct Account {\n    id: u32ï¼Œ\n    balance: u64ï¼Œ\n    account_type: Stringï¼Œ\n}\n\nstruct AccountFactory {\n    created_accounts: Vec<Account>ï¼Œ\n}\n\nimpl AccountFactory {\n    fn new() -> Self {\n        AccountFactory {\n            created_accounts: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn create_account(&mut selfï¼Œ id: u32ï¼Œ account_type: String) -> &Account {\n        let account = Account {\n            idï¼Œ\n            balance: 0ï¼Œ\n            account_typeï¼Œ\n        };\n        self.created_accounts.push(account);\n        self.created_accounts.last().unwrap()\n    }\n    \n    fn get_account(&selfï¼Œ id: u32) -> Option<&Account> {\n        self.created_accounts.iter().find(|acc| acc.id == id)\n    }\n}", "id": 19}
{"question_type": "short_answer", "instructions": "Optimize this Observer pattern implementation for a smart contract event system. The current design has performance issues with event notification and memory usage. Refactor to use efficient data structures and minimize allocations while maintaining the observer pattern's flexibility.", "contract_code": "use std::collections::HashMap;\n\ntrait EventObserver {\n    fn on_event(&selfï¼Œ event: Stringï¼Œ data: HashMap<Stringï¼Œ String>);\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<Stringï¼Œ Vec<Box<dyn EventObserver>>>ï¼Œ\n    event_history: Vec<(Stringï¼Œ HashMap<Stringï¼Œ String>)>ï¼Œ\n}\n\nimpl ContractEventSystem {\n    fn new() -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()ï¼Œ\n            event_history: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn subscribe(&mut selfï¼Œ event_type: Stringï¼Œ observer: Box<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut selfï¼Œ event_type: Stringï¼Œ data: HashMap<Stringï¼Œ String>) {\n        // Store full event history (memory intensive)\n        self.event_history.push((event_type.clone()ï¼Œ data.clone()));\n        \n        // Notify all observers (inefficient cloning)\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(event_type.clone()ï¼Œ data.clone());\n            }\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "optimizes_memory_usage", "points": 2, "keywords": ["memory", "allocation", "efficient"]}, {"criterion": "reduces_clone_operations", "points": 2, "keywords": ["clone", "borrow", "reference"]}, {"criterion": "maintains_observer_pattern", "points": 3, "check_function": "check_observer_pattern"}], "automated_tests": ["test_optimized_notifications", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\n\ntrait EventObserver {\n    fn on_event(&selfï¼Œ event: &strï¼Œ data: &HashMap<Stringï¼Œ String>);\n}\n\nstruct EventData {\n    event_type: Stringï¼Œ\n    data: HashMap<Stringï¼Œ String>ï¼Œ\n}\n\nstruct ContractEventSystem {\n    observers: HashMap<Stringï¼Œ Vec<Rc<dyn EventObserver>>>ï¼Œ\n    event_history: Vec<Rc<EventData>>ï¼Œ\n    max_history: usizeï¼Œ\n}\n\nimpl ContractEventSystem {\n    fn new(max_history: usize) -> Self {\n        ContractEventSystem {\n            observers: HashMap::new()ï¼Œ\n            event_history: Vec::new()ï¼Œ\n            max_historyï¼Œ\n        }\n    }\n    \n    fn subscribe(&mut selfï¼Œ event_type: Stringï¼Œ observer: Rc<dyn EventObserver>) {\n        self.observers.entry(event_type).or_insert_with(Vec::new).push(observer);\n    }\n    \n    fn emit_event(&mut selfï¼Œ event_type: Stringï¼Œ data: HashMap<Stringï¼Œ String>) {\n        let event_data = Rc::new(EventData { event_type: event_type.clone()ï¼Œ data });\n        \n        // Bounded history to prevent memory leaks\n        if self.event_history.len() >= self.max_history {\n            self.event_history.remove(0);\n        }\n        self.event_history.push(event_data.clone());\n        \n        // Efficient notification using references\n        if let Some(observers) = self.observers.get(&event_type) {\n            for observer in observers {\n                observer.on_event(&event_data.event_typeï¼Œ &event_data.data);\n            }\n        }\n    }\n}", "id": 20}
{"question_type": "refactoring", "instructions": "Refactor this tightly coupled smart contract system into a cleanï¼Œ modular architecture using dependency injection and the Command pattern. The current implementation violates single responsibility principle and makes testing difficult. Implement proper abstractions and demonstrate how the new design improves maintainability.", "contract_code": "struct WalletManager {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    transaction_log: Vec<String>ï¼Œ\n}\n\nimpl WalletManager {\n    fn new() -> Self {\n        WalletManager {\n            balances: std::collections::HashMap::new()ï¼Œ\n            transaction_log: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn transfer(&mut selfï¼Œ from: Stringï¼Œ to: Stringï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        // Validation logic mixed with business logic\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balances.get(&from).unwrap_or(&0);\n        if *from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        // Direct state manipulation\n        self.balances.insert(from.clone()ï¼Œ from_balance - amount);\n        let to_balance = self.balances.get(&to).unwrap_or(&0);\n        self.balances.insert(to.clone()ï¼Œ to_balance + amount);\n        \n        // Logging tightly coupled\n        self.transaction_log.push(format!(\"Transfer: {} -> {}: {}\"ï¼Œ fromï¼Œ toï¼Œ amount));\n        \n        // Hardcoded notification\n        println!(\"Transfer completed: {} to {}\"ï¼Œ fromï¼Œ to);\n        \n        Ok(())\n    }\n    \n    fn get_balance(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_dependency_injection", "points": 1, "keywords": ["dependency", "injection", "decoupled"]}, {"criterion": "applies_command_pattern", "points": 4, "check_function": "check_command_pattern"}, {"criterion": "separates_concerns", "points": 2, "keywords": ["separation", "responsibility", "modular"]}], "automated_tests": ["test_command_execution", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\n\ntrait BalanceStore {\n    fn get_balance(&selfï¼Œ account: &str) -> u64;\n    fn set_balance(&mut selfï¼Œ account: &strï¼Œ amount: u64);\n}\n\ntrait TransactionLogger {\n    fn log(&mut selfï¼Œ message: String);\n}\n\ntrait NotificationService {\n    fn notify(&selfï¼Œ message: String);\n}\n\nstruct InMemoryBalanceStore {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n}\n\nimpl BalanceStore for InMemoryBalanceStore {\n    fn get_balance(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n    \n    fn set_balance(&mut selfï¼Œ account: &strï¼Œ amount: u64) {\n        self.balances.insert(account.to_string()ï¼Œ amount);\n    }\n}\n\ntrait Command {\n    fn execute(&selfï¼Œ wallet: &mut WalletManager) -> Result<()ï¼Œ String>;\n}\n\nstruct TransferCommand {\n    from: Stringï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n}\n\nimpl Command for TransferCommand {\n    fn execute(&selfï¼Œ wallet: &mut WalletManager) -> Result<()ï¼Œ String> {\n        wallet.transfer(self.from.clone()ï¼Œ self.to.clone()ï¼Œ self.amount)\n    }\n}\n\nstruct WalletManager {\n    balance_store: Box<dyn BalanceStore>ï¼Œ\n    logger: Box<dyn TransactionLogger>ï¼Œ\n    notifier: Box<dyn NotificationService>ï¼Œ\n}\n\nimpl WalletManager {\n    fn new(balance_store: Box<dyn BalanceStore>ï¼Œ logger: Box<dyn TransactionLogger>ï¼Œ notifier: Box<dyn NotificationService>) -> Self {\n        WalletManager { balance_storeï¼Œ loggerï¼Œ notifier }\n    }\n    \n    fn transfer(&mut selfï¼Œ from: Stringï¼Œ to: Stringï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        if amount == 0 {\n            return Err(\"Amount must be positive\".to_string());\n        }\n        \n        let from_balance = self.balance_store.get_balance(&from);\n        if from_balance < amount {\n            return Err(\"Insufficient funds\".to_string());\n        }\n        \n        self.balance_store.set_balance(&fromï¼Œ from_balance - amount);\n        let to_balance = self.balance_store.get_balance(&to);\n        self.balance_store.set_balance(&toï¼Œ to_balance + amount);\n        \n        self.logger.log(format!(\"Transfer: {} -> {}: {}\"ï¼Œ fromï¼Œ toï¼Œ amount));\n        self.notifier.notify(format!(\"Transfer completed: {} to {}\"ï¼Œ fromï¼Œ to));\n        \n        Ok(())\n    }\n    \n    fn execute_command(&mut selfï¼Œ command: Box<dyn Command>) -> Result<()ï¼Œ String> {\n        command.execute(self)\n    }\n}", "id": 21}
{"question_type": "short_answer", "instructions": "Optimize this inefficient token transfer function that clones vectors unnecessarily and uses inappropriate data structures for performance", "contract_code": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: Stringï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n}\n\nstruct TokenContract {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    transactions: Vec<Transaction>ï¼Œ\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfï¼Œ from: Stringï¼Œ to: Stringï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let mut temp_transactions = self.transactions.clone();\n        let tx = Transaction { from: from.clone()ï¼Œ to: to.clone()ï¼Œ amount };\n        temp_transactions.push(tx.clone());\n        \n        if let Some(from_balance) = self.balances.get(&from) {\n            if *from_balance >= amount {\n                self.balances.insert(from.clone()ï¼Œ from_balance - amount);\n                let to_balance = self.balances.get(&to).unwrap_or(&0);\n                self.balances.insert(to.clone()ï¼Œ to_balance + amount);\n                self.transactions = temp_transactions;\n                Ok(())\n            } else {\n                Err(\"Insufficient balance\".to_string())\n            }\n        } else {\n            Err(\"Account not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 3, "keywords": ["clone", "unnecessary", "borrow", "reference"]}, {"criterion": "optimizes_data_structures", "points": 2, "keywords": ["HashMap", "entry", "or_insert", "get_mut"]}, {"criterion": "improves_memory_efficiency", "points": 2, "check_function": "check_memory_short_answer"}], "automated_tests": ["test_transfer_performance", "test_memory_usage"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Clone)]\nstruct Transaction {\n    from: Stringï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n}\n\nstruct TokenContract {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    transactions: Vec<Transaction>ï¼Œ\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let from_balance = self.balances.entry(from.to_string()).or_insert(0);\n        if *from_balance >= amount {\n            *from_balance -= amount;\n            *self.balances.entry(to.to_string()).or_insert(0) += amount;\n            self.transactions.push(Transaction { \n                from: from.to_string()ï¼Œ \n                to: to.to_string()ï¼Œ \n                amount \n            });\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\".to_string())\n        }\n    }\n}", "id": 22}
{"question_type": "code_audit", "instructions": "Identify and fix the resource management issue in this contract that causes memory leaks and inefficient resource usage", "contract_code": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64ï¼Œ\n    data: Vec<u8>ï¼Œ\n    metadata: Stringï¼Œ\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64ï¼Œ DataStorage>ï¼Œ\n    next_id: u64ï¼Œ\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()ï¼Œ\n            next_id: 1ï¼Œ\n        }\n    }\n    \n    fn store_data(&mut selfï¼Œ data: Vec<u8>ï¼Œ metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage {\n            idï¼Œ\n            data: data.clone()ï¼Œ\n            metadata: metadata.clone()ï¼Œ\n        };\n        \n        self.storage_map.insert(idï¼Œ storage);\n        id\n    }\n    \n    fn get_data(&selfï¼Œ id: u64) -> Option<Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| storage.data.clone())\n    }\n    \n    fn update_metadata(&mut selfï¼Œ id: u64ï¼Œ new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata.clone();\n            true\n        } else {\n            false\n        }\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_memory_leak", "points": 2, "keywords": ["clone", "memory", "leak", "unnecessary"]}, {"criterion": "fixes_resource_management", "points": 4, "check_function": "check_resource_short_answer"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_storage_contract"}], "automated_tests": ["test_storage_operations", "test_memory_efficiency"], "reference_solution": "use std::collections::BTreeMap;\n\nstruct DataStorage {\n    id: u64ï¼Œ\n    data: Vec<u8>ï¼Œ\n    metadata: Stringï¼Œ\n}\n\nstruct StorageContract {\n    storage_map: BTreeMap<u64ï¼Œ DataStorage>ï¼Œ\n    next_id: u64ï¼Œ\n}\n\nimpl StorageContract {\n    fn new() -> Self {\n        Self {\n            storage_map: BTreeMap::new()ï¼Œ\n            next_id: 1ï¼Œ\n        }\n    }\n    \n    fn store_data(&mut selfï¼Œ data: Vec<u8>ï¼Œ metadata: String) -> u64 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let storage = DataStorage { idï¼Œ dataï¼Œ metadata };\n        self.storage_map.insert(idï¼Œ storage);\n        id\n    }\n    \n    fn get_data(&selfï¼Œ id: u64) -> Option<&Vec<u8>> {\n        self.storage_map.get(&id).map(|storage| &storage.data)\n    }\n    \n    fn update_metadata(&mut selfï¼Œ id: u64ï¼Œ new_metadata: String) -> bool {\n        if let Some(storage) = self.storage_map.get_mut(&id) {\n            storage.metadata = new_metadata;\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 23}
{"question_type": "short_answer", "instructions": "Implement an efficient object pool pattern for this smart contract to reduce allocation overhead and improve performance for frequently created/destroyed objects", "contract_code": "struct Order {\n    id: u64ï¼Œ\n    user_id: u64ï¼Œ\n    amount: u64ï¼Œ\n    price: u64ï¼Œ\n    is_active: boolï¼Œ\n}\n\nstruct OrderBook {\n    orders: Vec<Order>ï¼Œ\n    next_id: u64ï¼Œ\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            orders: Vec::new()ï¼Œ\n            next_id: 1ï¼Œ\n        }\n    }\n    \n    fn create_order(&mut selfï¼Œ user_id: u64ï¼Œ amount: u64ï¼Œ price: u64) -> u64 {\n        let order = Order {\n            id: self.next_idï¼Œ\n            user_idï¼Œ\n            amountï¼Œ\n            priceï¼Œ\n            is_active: trueï¼Œ\n        };\n        self.next_id += 1;\n        self.orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut selfï¼Œ order_id: u64) -> bool {\n        if let Some(order) = self.orders.iter_mut().find(|o| o.id == order_id) {\n            order.is_active = false;\n            true\n        } else {\n            false\n        }\n    }\n    \n    fn cleanup_inactive_orders(&mut self) {\n        self.orders.retain(|order| order.is_active);\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_object_pool", "points": 1, "keywords": ["pool", "reuse", "allocate", "deallocate"]}, {"criterion": "reduces_allocation_overhead", "points": 2, "keywords": ["allocation", "overhead", "performance", "efficiency"]}, {"criterion": "maintains_memory_efficiency", "points": 3, "check_function": "check_pool_implementation"}], "automated_tests": ["test_object_pool_performance", "test_order_lifecycle"], "reference_solution": "struct Order {\n    id: u64ï¼Œ\n    user_id: u64ï¼Œ\n    amount: u64ï¼Œ\n    price: u64ï¼Œ\n    is_active: boolï¼Œ\n}\n\nstruct OrderPool {\n    available: Vec<Order>ï¼Œ\n    capacity: usizeï¼Œ\n}\n\nimpl OrderPool {\n    fn new(capacity: usize) -> Self {\n        Self {\n            available: Vec::with_capacity(capacity)ï¼Œ\n            capacityï¼Œ\n        }\n    }\n    \n    fn get_order(&mut selfï¼Œ id: u64ï¼Œ user_id: u64ï¼Œ amount: u64ï¼Œ price: u64) -> Order {\n        if let Some(mut order) = self.available.pop() {\n            order.id = id;\n            order.user_id = user_id;\n            order.amount = amount;\n            order.price = price;\n            order.is_active = true;\n            order\n        } else {\n            Order { idï¼Œ user_idï¼Œ amountï¼Œ priceï¼Œ is_active: true }\n        }\n    }\n    \n    fn return_order(&mut selfï¼Œ order: Order) {\n        if self.available.len() < self.capacity {\n            self.available.push(order);\n        }\n    }\n}\n\nstruct OrderBook {\n    active_orders: Vec<Order>ï¼Œ\n    order_pool: OrderPoolï¼Œ\n    next_id: u64ï¼Œ\n}\n\nimpl OrderBook {\n    fn new() -> Self {\n        Self {\n            active_orders: Vec::new()ï¼Œ\n            order_pool: OrderPool::new(100)ï¼Œ\n            next_id: 1ï¼Œ\n        }\n    }\n    \n    fn create_order(&mut selfï¼Œ user_id: u64ï¼Œ amount: u64ï¼Œ price: u64) -> u64 {\n        let order = self.order_pool.get_order(self.next_idï¼Œ user_idï¼Œ amountï¼Œ price);\n        self.next_id += 1;\n        self.active_orders.push(order);\n        self.next_id - 1\n    }\n    \n    fn cancel_order(&mut selfï¼Œ order_id: u64) -> bool {\n        if let Some(pos) = self.active_orders.iter().position(|o| o.id == order_id) {\n            let order = self.active_orders.remove(pos);\n            self.order_pool.return_order(order);\n            true\n        } else {\n            false\n        }\n    }\n}", "id": 24}
{"question_type": "short_answer", "instructions": "Optimize this batch processing function to handle large datasets efficiently without causing stack overflow or excessive memory usage", "contract_code": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<Stringï¼Œ Vec<u64>>ï¼Œ\n    results: Vec<ProcessingResult>ï¼Œ\n}\n\nstruct ProcessingResult {\n    key: Stringï¼Œ\n    sum: u64ï¼Œ\n    count: usizeï¼Œ\n    average: f64ï¼Œ\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()ï¼Œ\n            results: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn process_batch(&mut selfï¼Œ batch_data: Vec<(Stringï¼Œ Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::new();\n        \n        for (keyï¼Œ values) in batch_data {\n            // Store in cache\n            self.data_cache.insert(key.clone()ï¼Œ values.clone());\n            \n            // Process immediately\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()ï¼Œ\n                sumï¼Œ\n                countï¼Œ\n                averageï¼Œ\n            };\n            \n            results.push(result.clone());\n            self.results.push(result);\n        }\n        \n        results\n    }\n    \n    fn get_cached_data(&selfï¼Œ key: &str) -> Option<Vec<u64>> {\n        self.data_cache.get(key).cloned()\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_cloning", "points": 2, "keywords": ["clone", "reference", "borrow", "move"]}, {"criterion": "optimizes_batch_processing", "points": 2, "keywords": ["iterator", "chunks", "streaming", "batch"]}, {"criterion": "improves_memory_management", "points": 3, "check_function": "check_batch_short_answer"}], "automated_tests": ["test_large_batch_processing", "test_memory_usage_short_answer"], "reference_solution": "use std::collections::HashMap;\n\nstruct BatchProcessor {\n    data_cache: HashMap<Stringï¼Œ Vec<u64>>ï¼Œ\n    results: Vec<ProcessingResult>ï¼Œ\n}\n\nstruct ProcessingResult {\n    key: Stringï¼Œ\n    sum: u64ï¼Œ\n    count: usizeï¼Œ\n    average: f64ï¼Œ\n}\n\nimpl BatchProcessor {\n    fn new() -> Self {\n        Self {\n            data_cache: HashMap::new()ï¼Œ\n            results: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn process_batch(&mut selfï¼Œ batch_data: Vec<(Stringï¼Œ Vec<u64>)>) -> Vec<ProcessingResult> {\n        let mut results = Vec::with_capacity(batch_data.len());\n        \n        for (keyï¼Œ values) in batch_data {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult {\n                key: key.clone()ï¼Œ\n                sumï¼Œ\n                countï¼Œ\n                averageï¼Œ\n            };\n            \n            results.push(result);\n            self.data_cache.insert(keyï¼Œ values);\n        }\n        \n        self.results.extend(results.iter().cloned());\n        results\n    }\n    \n    fn get_cached_data(&selfï¼Œ key: &str) -> Option<&Vec<u64>> {\n        self.data_cache.get(key)\n    }\n    \n    fn process_streaming(&mut selfï¼Œ data_stream: impl Iterator<Item = (Stringï¼Œ Vec<u64>)>) -> impl Iterator<Item = ProcessingResult> + '_ {\n        data_stream.map(|(keyï¼Œ values)| {\n            let sum: u64 = values.iter().sum();\n            let count = values.len();\n            let average = sum as f64 / count as f64;\n            \n            let result = ProcessingResult { key: key.clone()ï¼Œ sumï¼Œ countï¼Œ average };\n            self.data_cache.insert(keyï¼Œ values);\n            result\n        })\n    }\n    \n    fn clear_cache(&mut self) {\n        self.data_cache.clear();\n        self.results.clear();\n    }\n}", "id": 25}
{"question_type": "short_answer", "instructions": "Write comprehensive unit tests for this token contract focusing on edge cases and proper error handling. Identify any missing test scenarios.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debugï¼Œ PartialEq)]\npub enum TokenError {\n    InsufficientBalanceï¼Œ\n    InvalidAmountï¼Œ\n}\n\npub struct Token {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl Token {\n    pub fn new(initial_supply: u64) -> Self {\n        let mut balances = HashMap::new();\n        balances.insert(\"owner\".to_string()ï¼Œ initial_supply);\n        Token { balancesï¼Œ total_supply: initial_supply }\n    }\n    \n    pub fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ TokenError> {\n        if amount == 0 { return Err(TokenError::InvalidAmount); }\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance < amount { return Err(TokenError::InsufficientBalance); }\n        \n        self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n    \n    pub fn balance(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "tests_edge_cases", "points": 3, "keywords": ["zero_amount", "nonexistent_account", "overflow"]}, {"criterion": "proper_test_structure", "points": 2, "keywords": ["#[test]", "assert_eq", "assert"]}, {"criterion": "error_handling_tests", "points": 2, "keywords": ["Result", "unwrap", "expect", "match"]}], "automated_tests": ["test_token_functionality", "test_error_scenarios"], "reference_solution": "#[cfg(test)]\nmod tests {\n    use super::*;\n    \n    #[test]\n    fn test_transfer_success() {\n        let mut token = Token::new(1000);\n        assert!(token.transfer(\"owner\"ï¼Œ \"alice\"ï¼Œ 100).is_ok());\n        assert_eq!(token.balance(\"alice\")ï¼Œ 100);\n        assert_eq!(token.balance(\"owner\")ï¼Œ 900);\n    }\n    \n    #[test]\n    fn test_insufficient_balance() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"alice\"ï¼Œ \"bob\"ï¼Œ 100)ï¼Œ Err(TokenError::InsufficientBalance));\n    }\n    \n    #[test]\n    fn test_zero_amount_transfer() {\n        let mut token = Token::new(1000);\n        assert_eq!(token.transfer(\"owner\"ï¼Œ \"alice\"ï¼Œ 0)ï¼Œ Err(TokenError::InvalidAmount));\n    }\n}", "id": 26}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this staking contract and provide a secure implementation with proper overflow checks.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingPool {\n    stakes: HashMap<Stringï¼Œ u64>ï¼Œ\n    rewards: HashMap<Stringï¼Œ u64>ï¼Œ\n    reward_rate: u64ï¼Œ\n}\n\nimpl StakingPool {\n    pub fn new(reward_rate: u64) -> Self {\n        StakingPool {\n            stakes: HashMap::new()ï¼Œ\n            rewards: HashMap::new()ï¼Œ\n            reward_rateï¼Œ\n        }\n    }\n    \n    pub fn stake(&mut selfï¼Œ user: &strï¼Œ amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()ï¼Œ current_stake + amount);\n    }\n    \n    pub fn calculate_rewards(&mut selfï¼Œ user: &strï¼Œ time_elapsed: u64) {\n        let stake_amount = self.stakes.get(user).unwrap_or(&0);\n        let reward = stake_amount * self.reward_rate * time_elapsed / 100;\n        let current_rewards = self.rewards.get(user).unwrap_or(&0);\n        self.rewards.insert(user.to_string()ï¼Œ current_rewards + reward);\n    }\n    \n    pub fn get_stake(&selfï¼Œ user: &str) -> u64 {\n        *self.stakes.get(user).unwrap_or(&0)\n    }\n    \n    pub fn get_rewards(&selfï¼Œ user: &str) -> u64 {\n        *self.rewards.get(user).unwrap_or(&0)\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 2, "keywords": ["overflow", "saturating", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_overflow_protection"}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_contract_logic"}], "automated_tests": ["test_overflow_protection", "test_staking_functionality"], "reference_solution": "pub fn stake(&mut selfï¼Œ user: &strï¼Œ amount: u64) {\n    let current_stake = self.stakes.get(user).unwrap_or(&0);\n    self.stakes.insert(user.to_string()ï¼Œ current_stake.saturating_add(amount));\n}\n\npub fn calculate_rewards(&mut selfï¼Œ user: &strï¼Œ time_elapsed: u64) -> Result<()ï¼Œ &'static str> {\n    let stake_amount = self.stakes.get(user).unwrap_or(&0);\n    let reward = stake_amount.checked_mul(self.reward_rate)\n        .and_then(|r| r.checked_mul(time_elapsed))\n        .and_then(|r| r.checked_div(100))\n        .ok_or(\"Reward calculation overflow\")?;\n    let current_rewards = self.rewards.get(user).unwrap_or(&0);\n    self.rewards.insert(user.to_string()ï¼Œ current_rewards.saturating_add(reward));\n    Ok(())\n}", "id": 27}
{"question_type": "short_answer", "instructions": "Refactor this voting contract to implement proper state management using Rust's ownership system and eliminate the use of RefCell for thread-safe state mutations.", "contract_code": "use std::collections::HashMap;\nuse std::cell::RefCell;\nuse std::rc::Rc;\n\n#[derive(Clone)]\npub struct Proposal {\n    id: u32ï¼Œ\n    title: Stringï¼Œ\n    votes_for: u32ï¼Œ\n    votes_against: u32ï¼Œ\n    active: boolï¼Œ\n}\n\npub struct VotingSystem {\n    proposals: Rc<RefCell<HashMap<u32ï¼Œ Proposal>>>ï¼Œ\n    voters: Rc<RefCell<HashMap<Stringï¼Œ Vec<u32>>>>ï¼Œ\n    next_id: Rc<RefCell<u32>>ï¼Œ\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: Rc::new(RefCell::new(HashMap::new()))ï¼Œ\n            voters: Rc::new(RefCell::new(HashMap::new()))ï¼Œ\n            next_id: Rc::new(RefCell::new(1))ï¼Œ\n        }\n    }\n    \n    pub fn create_proposal(&selfï¼Œ title: String) -> u32 {\n        let id = *self.next_id.borrow();\n        *self.next_id.borrow_mut() += 1;\n        \n        let proposal = Proposal {\n            idï¼Œ\n            titleï¼Œ\n            votes_for: 0ï¼Œ\n            votes_against: 0ï¼Œ\n            active: trueï¼Œ\n        };\n        \n        self.proposals.borrow_mut().insert(idï¼Œ proposal);\n        id\n    }\n    \n    pub fn vote(&selfï¼Œ voter: &strï¼Œ proposal_id: u32ï¼Œ vote_for: bool) -> Result<()ï¼Œ String> {\n        let mut voted_proposals = self.voters.borrow_mut();\n        let user_votes = voted_proposals.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.borrow_mut().get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "eliminates_refcell_usage", "points": 2, "keywords": ["RefCell", "interior_mutability", "ownership"]}, {"criterion": "implements_proper_ownership", "points": 2, "keywords": ["&mut self", "borrow", "move"]}, {"criterion": "maintains_thread_safety", "points": 3, "keywords": ["Send", "Sync", "thread_safe", "mutex"]}], "automated_tests": ["test_voting_functionality", "test_thread_safety"], "reference_solution": "pub struct VotingSystem {\n    proposals: HashMap<u32ï¼Œ Proposal>ï¼Œ\n    voters: HashMap<Stringï¼Œ Vec<u32>>ï¼Œ\n    next_id: u32ï¼Œ\n}\n\nimpl VotingSystem {\n    pub fn new() -> Self {\n        VotingSystem {\n            proposals: HashMap::new()ï¼Œ\n            voters: HashMap::new()ï¼Œ\n            next_id: 1ï¼Œ\n        }\n    }\n    \n    pub fn create_proposal(&mut selfï¼Œ title: String) -> u32 {\n        let id = self.next_id;\n        self.next_id += 1;\n        \n        let proposal = Proposal {\n            idï¼Œ\n            titleï¼Œ\n            votes_for: 0ï¼Œ\n            votes_against: 0ï¼Œ\n            active: trueï¼Œ\n        };\n        \n        self.proposals.insert(idï¼Œ proposal);\n        id\n    }\n    \n    pub fn vote(&mut selfï¼Œ voter: &strï¼Œ proposal_id: u32ï¼Œ vote_for: bool) -> Result<()ï¼Œ String> {\n        let user_votes = self.voters.entry(voter.to_string()).or_insert(Vec::new());\n        \n        if user_votes.contains(&proposal_id) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        user_votes.push(proposal_id);\n        \n        if let Some(proposal) = self.proposals.get_mut(&proposal_id) {\n            if vote_for {\n                proposal.votes_for += 1;\n            } else {\n                proposal.votes_against += 1;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 28}
{"question_type": "short_answer", "instructions": "Debug and optimize this auction contract that has performance issues with large numbers of bidders. Identify bottlenecks and implement efficient data structures.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debugï¼Œ Clone)]\npub struct Bid {\n    bidder: Stringï¼Œ\n    amount: u64ï¼Œ\n    timestamp: u64ï¼Œ\n}\n\npub struct Auction {\n    item_id: u32ï¼Œ\n    all_bids: Vec<Bid>ï¼Œ\n    bidder_amounts: HashMap<Stringï¼Œ u64>ï¼Œ\n    end_time: u64ï¼Œ\n}\n\nimpl Auction {\n    pub fn new(item_id: u32ï¼Œ end_time: u64) -> Self {\n        Auction {\n            item_idï¼Œ\n            all_bids: Vec::new()ï¼Œ\n            bidder_amounts: HashMap::new()ï¼Œ\n            end_timeï¼Œ\n        }\n    }\n    \n    pub fn place_bid(&mut selfï¼Œ bidder: Stringï¼Œ amount: u64ï¼Œ timestamp: u64) -> Result<()ï¼Œ String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        // Check if bid is higher than current highest\n        let current_highest = self.get_highest_bid();\n        if amount <= current_highest {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        let bid = Bid { bidder: bidder.clone()ï¼Œ amountï¼Œ timestamp };\n        self.all_bids.push(bid);\n        self.bidder_amounts.insert(bidderï¼Œ amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        let mut highest = 0;\n        for bid in &self.all_bids {\n            if bid.amount > highest {\n                highest = bid.amount;\n            }\n        }\n        highest\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        let highest_amount = self.get_highest_bid();\n        for bid in &self.all_bids {\n            if bid.amount == highest_amount {\n                return Some(bid.bidder.clone());\n            }\n        }\n        None\n    }\n    \n    pub fn get_bid_history(&self) -> Vec<Bid> {\n        let mut sorted_bids = self.all_bids.clone();\n        sorted_bids.sort_by(|aï¼Œ b| b.amount.cmp(&a.amount));\n        sorted_bids\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "identifies_performance_bottlenecks", "points": 1, "keywords": ["O(n)", "linear_search", "inefficient"]}, {"criterion": "implements_efficient_data_structures", "points": 4, "keywords": ["BTreeMap", "heap", "binary_search", "short_answer"]}, {"criterion": "maintains_correctness", "points": 2, "check_function": "validate_auction_logic"}], "automated_tests": ["test_auction_performance", "test_bid_correctness"], "reference_solution": "use std::collections::{HashMapï¼Œ BTreeMap};\n\npub struct Auction {\n    item_id: u32ï¼Œ\n    highest_bid: u64ï¼Œ\n    highest_bidder: Option<String>ï¼Œ\n    bid_history: BTreeMap<u64ï¼Œ (Stringï¼Œ u64)>ï¼Œ // amount -> (bidderï¼Œ timestamp)\n    bidder_amounts: HashMap<Stringï¼Œ u64>ï¼Œ\n    end_time: u64ï¼Œ\n}\n\nimpl Auction {\n    pub fn new(item_id: u32ï¼Œ end_time: u64) -> Self {\n        Auction {\n            item_idï¼Œ\n            highest_bid: 0ï¼Œ\n            highest_bidder: Noneï¼Œ\n            bid_history: BTreeMap::new()ï¼Œ\n            bidder_amounts: HashMap::new()ï¼Œ\n            end_timeï¼Œ\n        }\n    }\n    \n    pub fn place_bid(&mut selfï¼Œ bidder: Stringï¼Œ amount: u64ï¼Œ timestamp: u64) -> Result<()ï¼Œ String> {\n        if timestamp > self.end_time {\n            return Err(\"Auction ended\".to_string());\n        }\n        \n        if amount <= self.highest_bid {\n            return Err(\"Bid too low\".to_string());\n        }\n        \n        self.highest_bid = amount;\n        self.highest_bidder = Some(bidder.clone());\n        self.bid_history.insert(amountï¼Œ (bidder.clone()ï¼Œ timestamp));\n        self.bidder_amounts.insert(bidderï¼Œ amount);\n        Ok(())\n    }\n    \n    pub fn get_highest_bid(&self) -> u64 {\n        self.highest_bid\n    }\n    \n    pub fn get_winner(&self) -> Option<String> {\n        self.highest_bidder.clone()\n    }\n}", "id": 29}
{"question_type": "code_audit", "instructions": "Identify and fix the issues in the cross-contract interface design related to error handlingï¼Œ specifically focusing on blockchain-specific errors like gas exhaustion and transaction reversion. Provide a revised version of the contract that includes robust error handling and ensures secure cross-contract calls.", "factors_to_consider": ["Blockchain-specific error handling", "Gas management and transaction costs", "Security of cross-contract calls", "Compatibility with existing blockchain protocols"], "keywords": ["blockchain", "gas exhaustion", "transaction reversion", "cross-contract calls", "error handling"], "expected_insights": ["Understanding of blockchain-specific error types", "Ability to implement secure and efficient cross-contract calls", "Knowledge of gas management in blockchain transactions", "Insight into maintaining protocol compatibility"], "scoring_criteria": [{"criterion": "Identifies blockchain-specific error handling issues", "points": 3, "key_points": ["Recognizes gas exhaustion", "Identifies transaction reversion"]}, {"criterion": "Implements robust error handling", "points": 3, "key_points": ["Uses Result types effectively", "Handles errors without panicking"]}, {"criterion": "Ensures secure cross-contract calls", "points": 2, "key_points": ["Prevents reentrancy attacks", "Validates external call responses"]}, {"criterion": "Maintains compatibility with blockchain protocols", "points": 2, "key_points": ["Adheres to interface standards", "Ensures backward compatibility"]}], "total_possible": 10, "id": 30, "contract_code": "// A simple contract that can be called by another contract.\n// It has a function that can either revert or consume a lot of gas.\npub mod callee {\n    use cosmwasm_std::{Responseï¼Œ StdError};\n\n    pub fn do_work(gas_limit: u64) -> Result<Responseï¼Œ StdError> {\n        if gas_limit > 100_000 {\n            // Simulate gas exhaustion\n            let mut i = 0;\n            while i < gas_limit {\n                i += 1;\n            }\n        }\n        Ok(Response::new())\n    }\n\n    pub fn do_work_and_revert() -> Result<Responseï¼Œ StdError> {\n        Err(StdError::generic_err(\n            \"This function is designed to revert\"ï¼Œ\n        ))\n    }\n}\n\n// A contract that calls the callee contract but does not handle errors properly.\npub mod caller {\n    use super::callee;\n    use cosmwasm_std::{CosmosMsgï¼Œ Responseï¼Œ StdErrorï¼Œ SubMsg};\n\n    pub fn call_callee_and_ignore_error(gas_limit: u64) -> Result<Responseï¼Œ StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()ï¼Œ\n            msg: cosmwasm_std::to_binary(&callee::do_work(gas_limit))?ï¼Œ\n            funds: vec![]ï¼Œ\n        });\n\n        // The error from the sub-message is not handled.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n\n    pub fn call_callee_and_panic() -> Result<Responseï¼Œ StdError> {\n        let msg = CosmosMsg::Wasm(cosmwasm_std::WasmMsg::Execute {\n            contract_addr: \"callee_address\".to_string()ï¼Œ\n            msg: cosmwasm_std::to_binary(&callee::do_work_and_revert())?ï¼Œ\n            funds: vec![]ï¼Œ\n        });\n\n        // This will panic if the sub-message fails.\n        let sub_msg = SubMsg::new(msg);\n        Ok(Response::new().add_submessage(sub_msg))\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Implement a secure proxy pattern for cross-contract interactions that handles ownership of the proxied contract reference and prevents unauthorized access", "contract_code": "trait ContractInterface {\n    fn execute(&mut selfï¼Œ data: Vec<u8>) -> Result<Vec<u8>ï¼Œ String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: ContractInterfaceï¼Œ\n    admin: Stringï¼Œ\n}\n\nimpl ProxyContract {\n    fn new(target: ContractInterfaceï¼Œ admin: String) -> Self {\n        Self { targetï¼Œ admin }\n    }\n    \n    fn call(&selfï¼Œ caller: Stringï¼Œ data: Vec<u8>) -> Result<Vec<u8>ï¼Œ String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&selfï¼Œ new_target: ContractInterface) {\n        self.target = new_target;\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "fixes_ownership_issues", "points": 2, "keywords": ["Box", "dyn", "trait object"]}, {"criterion": "implements_access_control", "points": 4, "check_function": "check_access_control_logic"}, {"criterion": "handles_mutable_references", "points": 2, "check_function": "validate_mutability_handling"}], "automated_tests": ["test_proxy_authorization", "test_upgrade_security", "test_ownership_compilation"], "reference_solution": "trait ContractInterface {\n    fn execute(&mut selfï¼Œ data: Vec<u8>) -> Result<Vec<u8>ï¼Œ String>;\n    fn get_owner(&self) -> String;\n}\n\nstruct ProxyContract {\n    target: Box<dyn ContractInterface>ï¼Œ\n    admin: Stringï¼Œ\n}\n\nimpl ProxyContract {\n    fn new(target: Box<dyn ContractInterface>ï¼Œ admin: String) -> Self {\n        Self { targetï¼Œ admin }\n    }\n    \n    fn call(&mut selfï¼Œ caller: Stringï¼Œ data: Vec<u8>) -> Result<Vec<u8>ï¼Œ String> {\n        self.target.execute(data)\n    }\n    \n    fn upgrade(&mut selfï¼Œ caller: Stringï¼Œ new_target: Box<dyn ContractInterface>) -> Result<()ï¼Œ String> {\n        if caller != self.admin {\n            return Err(\"Unauthorized: Only admin can upgrade\".to_string());\n        }\n        self.target = new_target;\n        Ok(())\n    }\n}", "id": 31}
{"question_type": "short_answer", "instructions": "Optimize the cross-contract batch call system to minimize unnecessary cloning and improve memory efficiency while maintaining interface compatibility", "contract_code": "trait BatchCallable {\n    fn batch_call(&selfï¼Œ calls: Vec<CallData>) -> Vec<Result<Vec<u8>ï¼Œ String>>;\n}\n\n#[derive(Clone)]\nstruct CallData {\n    contract_address: Stringï¼Œ\n    method: Stringï¼Œ\n    args: Vec<u8>ï¼Œ\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>ï¼Œ\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&selfï¼Œ calls: Vec<CallData>) -> Vec<Result<Vec<u8>ï¼Œ String>> {\n        let mut results = Vec::new();\n        \n        for call in calls {\n            let contract_addr = call.contract_address.clone();\n            let method = call.method.clone();\n            let args = call.args.clone();\n            \n            let result = self.execute_single_call(contract_addrï¼Œ methodï¼Œ args);\n            results.push(result);\n        }\n        \n        results\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&selfï¼Œ addr: Stringï¼Œ method: Stringï¼Œ args: Vec<u8>) -> Result<Vec<u8>ï¼Œ String> {\n        // Simulate external call\n        Ok(vec![1ï¼Œ 2ï¼Œ 3])\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 1, "keywords": ["borrow", "reference", "&"]}, {"criterion": "optimizes_memory_usage", "points": 4, "check_function": "check_memory_short_answer"}, {"criterion": "maintains_interface_contract", "points": 2, "check_function": "validate_interface_preservation"}], "automated_tests": ["test_batch_call_short_answer", "test_memory_efficiency", "test_interface_compatibility"], "reference_solution": "trait BatchCallable {\n    fn batch_call(&selfï¼Œ calls: &[CallData]) -> Vec<Result<Vec<u8>ï¼Œ String>>;\n}\n\nstruct CallData {\n    contract_address: Stringï¼Œ\n    method: Stringï¼Œ\n    args: Vec<u8>ï¼Œ\n}\n\nstruct BatchProcessor {\n    contracts: Vec<String>ï¼Œ\n}\n\nimpl BatchCallable for BatchProcessor {\n    fn batch_call(&selfï¼Œ calls: &[CallData]) -> Vec<Result<Vec<u8>ï¼Œ String>> {\n        calls.iter()\n            .map(|call| {\n                self.execute_single_call(&call.contract_addressï¼Œ &call.methodï¼Œ &call.args)\n            })\n            .collect()\n    }\n}\n\nimpl BatchProcessor {\n    fn execute_single_call(&selfï¼Œ addr: &strï¼Œ method: &strï¼Œ args: &[u8]) -> Result<Vec<u8>ï¼Œ String> {\n        // Simulate external call\n        Ok(vec![1ï¼Œ 2ï¼Œ 3])\n    }\n}", "id": 32}
{"question_type": "short_answer", "instructions": "Write comprehensive tests for the cross-contract callback system and fix the callback registration mechanism that has a state management vulnerability", "contract_code": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut selfï¼Œ caller: Stringï¼Œ data: Vec<u8>) -> Result<()ï¼Œ String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<Stringï¼Œ Box<dyn CallbackHandler>>ï¼Œ\n    pending_calls: Vec<(Stringï¼Œ Vec<u8>)>ï¼Œ\n}\n\nimpl CallbackRegistry {\n    fn new() -> Self {\n        Self {\n            callbacks: HashMap::new()ï¼Œ\n            pending_calls: Vec::new()ï¼Œ\n        }\n    }\n    \n    fn register_callback(&mut selfï¼Œ contract_id: Stringï¼Œ handler: Box<dyn CallbackHandler>) {\n        self.callbacks.insert(contract_idï¼Œ handler);\n    }\n    \n    fn execute_callback(&mut selfï¼Œ contract_id: Stringï¼Œ data: Vec<u8>) -> Result<()ï¼Œ String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()ï¼Œ data)\n        } else {\n            self.pending_calls.push((contract_idï¼Œ data));\n            Ok(())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_issue", "points": 2, "keywords": ["pending", "memory leak", "unbounded"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "check_function": "check_test_coverage"}, {"criterion": "fixes_state_management", "points": 3, "check_function": "validate_state_fix"}], "automated_tests": ["test_callback_registration", "test_pending_calls_handling", "test_state_cleanup"], "reference_solution": "use std::collections::HashMap;\n\ntrait CallbackHandler {\n    fn handle_callback(&mut selfï¼Œ caller: Stringï¼Œ data: Vec<u8>) -> Result<()ï¼Œ String>;\n}\n\nstruct CallbackRegistry {\n    callbacks: HashMap<Stringï¼Œ Box<dyn CallbackHandler>>ï¼Œ\n    pending_calls: HashMap<Stringï¼Œ Vec<Vec<u8>>>ï¼Œ\n    max_pending_per_contract: usizeï¼Œ\n}\n\nimpl CallbackRegistry {\n    fn new(max_pending: usize) -> Self {\n        Self {\n            callbacks: HashMap::new()ï¼Œ\n            pending_calls: HashMap::new()ï¼Œ\n            max_pending_per_contract: max_pendingï¼Œ\n        }\n    }\n    \n    fn register_callback(&mut selfï¼Œ contract_id: Stringï¼Œ handler: Box<dyn CallbackHandler>) -> Result<()ï¼Œ String> {\n        self.callbacks.insert(contract_id.clone()ï¼Œ handler);\n        \n        if let Some(pending) = self.pending_calls.remove(&contract_id) {\n            for data in pending {\n                if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n                    handler.handle_callback(contract_id.clone()ï¼Œ data)?;\n                }\n            }\n        }\n        Ok(())\n    }\n    \n    fn execute_callback(&mut selfï¼Œ contract_id: Stringï¼Œ data: Vec<u8>) -> Result<()ï¼Œ String> {\n        if let Some(handler) = self.callbacks.get_mut(&contract_id) {\n            handler.handle_callback(contract_id.clone()ï¼Œ data)\n        } else {\n            let pending = self.pending_calls.entry(contract_id.clone()).or_insert_with(Vec::new);\n            if pending.len() >= self.max_pending_per_contract {\n                return Err(\"Too many pending callbacks for contract\".to_string());\n            }\n            pending.push(data);\n            Ok(())\n        }\n    }\n}", "id": 33}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks.", "contract_code": "pub struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl Token {\n    pub fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 2, "check_function": "check_safe_arithmetic"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_protection", "test_normal_transfer"], "reference_solution": "pub struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl Token {\n    pub fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()ï¼Œ new_balance);\n                    return true;\n                }\n                None => return falseï¼Œ\n            }\n        }\n        false\n    }\n}", "id": 34}
{"question_type": "short_answer", "instructions": "Fix the access control vulnerability in this governance contract by implementing proper authorization checks and state management patterns.", "contract_code": "pub struct GovernanceContract {\n    owner: Stringï¼Œ\n    proposals: Vec<Proposal>ï¼Œ\n    voting_power: std::collections::HashMap<Stringï¼Œ u32>ï¼Œ\n}\n\npub struct Proposal {\n    id: u32ï¼Œ\n    description: Stringï¼Œ\n    votes_for: u32ï¼Œ\n    votes_against: u32ï¼Œ\n    executed: boolï¼Œ\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut selfï¼Œ proposal_id: u32ï¼Œ executor: &str) {\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            proposal.executed = true;\n            // Execute proposal logic here\n        }\n    }\n    \n    pub fn vote(&mut selfï¼Œ voter: &strï¼Œ proposal_id: u32ï¼Œ support: bool) {\n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n        }\n    }\n}", "vulnerability_type": "access_control", "scoring_criteria": [{"criterion": "identifies_access_control_flaws", "points": 2, "keywords": ["authorization", "permission", "access", "security"]}, {"criterion": "implements_proper_checks", "points": 4, "check_function": "check_access_control"}, {"criterion": "prevents_unauthorized_execution", "points": 1, "check_function": "validate_authorization"}], "automated_tests": ["test_unauthorized_execution", "test_double_voting", "test_valid_execution"], "reference_solution": "pub struct GovernanceContract {\n    owner: Stringï¼Œ\n    proposals: Vec<Proposal>ï¼Œ\n    voting_power: std::collections::HashMap<Stringï¼Œ u32>ï¼Œ\n    voted: std::collections::HashMap<(Stringï¼Œ u32)ï¼Œ bool>ï¼Œ\n}\n\nimpl GovernanceContract {\n    pub fn execute_proposal(&mut selfï¼Œ proposal_id: u32ï¼Œ executor: &str) -> Result<()ï¼Œ String> {\n        if executor != self.owner {\n            return Err(\"Unauthorized executor\".to_string());\n        }\n        \n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            if proposal.votes_for <= proposal.votes_against {\n                return Err(\"Insufficient votes\".to_string());\n            }\n            proposal.executed = true;\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n    \n    pub fn vote(&mut selfï¼Œ voter: &strï¼Œ proposal_id: u32ï¼Œ support: bool) -> Result<()ï¼Œ String> {\n        let vote_key = (voter.to_string()ï¼Œ proposal_id);\n        if self.voted.contains_key(&vote_key) {\n            return Err(\"Already voted\".to_string());\n        }\n        \n        let power = *self.voting_power.get(voter).unwrap_or(&1);\n        if let Some(proposal) = self.proposals.get_mut(proposal_id as usize) {\n            if proposal.executed {\n                return Err(\"Proposal already executed\".to_string());\n            }\n            self.voted.insert(vote_keyï¼Œ true);\n            if support {\n                proposal.votes_for += power;\n            } else {\n                proposal.votes_against += power;\n            }\n            Ok(())\n        } else {\n            Err(\"Proposal not found\".to_string())\n        }\n    }\n}", "id": 35}
{"question_type": "code_audit", "instructions": "Identify and fix the error handling vulnerability in this staking contract that could lead to panics and denial of service attacks. Address the specific issues related to token decimal handlingï¼Œ error handling robustnessï¼Œ and ensure all potential edge cases are covered.", "contract_code": "use std::collections::HashMap;\n\npub struct StakingContract {\n    stakes: HashMap<Stringï¼Œ u64>ï¼Œ\n    rewards: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_staked: u64ï¼Œ\n}\n\nimpl StakingContract {\n    pub fn stake(&mut selfï¼Œ user: &strï¼Œ amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        self.stakes.insert(user.to_string()ï¼Œ current_stake + amount);\n        self.total_staked += amount;\n    }\n    \n    pub fn unstake(&mut selfï¼Œ user: &strï¼Œ amount: u64) {\n        let current_stake = self.stakes.get(user).unwrap();\n        assert!(current_stake >= &amountï¼Œ \"Insufficient stake\");\n        self.stakes.insert(user.to_string()ï¼Œ current_stake - amount);\n        self.total_staked -= amount;\n    }\n    \n    pub fn claim_rewards(&mut selfï¼Œ user: &str) -> u64 {\n        let reward = self.rewards.get(user).unwrap();\n        self.rewards.insert(user.to_string()ï¼Œ 0);\n        *reward\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_vulnerabilities", "points": 2, "keywords": ["panic", "unwrap", "assert", "Result"]}, {"criterion": "implements_safe_error_handling", "points": 2, "check_function": "check_error_handling"}, {"criterion": "maintains_contract_robustness", "points": 3, "check_function": "validate_robustness"}], "automated_tests": ["test_panic_prevention", "test_error_propagation", "test_edge_cases", "test_decimal_token_support"], "reference_solution": "use std::collections::HashMap;\n\n#[derive(Debug)]\npub enum StakingError {\n    UserNotFoundï¼Œ\n    InsufficientStakeï¼Œ\n    NoRewardsï¼Œ\n    InvalidDecimalTokenï¼Œ\n}\n\npub struct StakingContract {\n    stakes: HashMap<Stringï¼Œ u64>ï¼Œ\n    rewards: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_staked: u64ï¼Œ\n}\n\nimpl StakingContract {\n    pub fn stake(&mut selfï¼Œ user: &strï¼Œ amount: u64) -> Result<()ï¼Œ StakingError> {\n        let current_stake = self.stakes.get(user).unwrap_or(&0);\n        self.stakes.insert(user.to_string()ï¼Œ current_stake + amount);\n        self.total_staked += amount;\n        Ok(())\n    }\n    \n    pub fn unstake(&mut selfï¼Œ user: &strï¼Œ amount: u64) -> Result<()ï¼Œ StakingError> {\n        let current_stake = self.stakes.get(user).ok_or(StakingError::UserNotFound)?;\n        if current_stake < &amount {\n            return Err(StakingError::InsufficientStake);\n        }\n        self.stakes.insert(user.to_string()ï¼Œ current_stake - amount);\n        self.total_staked -= amount;\n        Ok(())\n    }\n    \n    pub fn claim_rewards(&mut selfï¼Œ user: &str) -> Result<u64ï¼Œ StakingError> {\n        let reward = self.rewards.get(user).ok_or(StakingError::UserNotFound)?;\n        if *reward == 0 {\n            return Err(StakingError::NoRewards);\n        }\n        let reward_amount = *reward;\n        self.rewards.insert(user.to_string()ï¼Œ 0);\n        Ok(reward_amount)\n    }\n}", "id": 36}
{"question_type": "short_answer", "instructions": "Identify the state management vulnerability in this multi-signature wallet and refactor it to prevent race conditions and ensure atomic operations.", "contract_code": "use std::collections::HashMap;\n\npub struct MultiSigWallet {\n    owners: Vec<String>ï¼Œ\n    required_confirmations: u32ï¼Œ\n    transactions: Vec<Transaction>ï¼Œ\n    confirmations: HashMap<u32ï¼Œ Vec<String>>ï¼Œ\n}\n\npub struct Transaction {\n    id: u32ï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n    executed: boolï¼Œ\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut selfï¼Œ owner: &strï¼Œ to: Stringï¼Œ amount: u64) -> u32 {\n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_idï¼Œ\n            toï¼Œ\n            amountï¼Œ\n            executed: falseï¼Œ\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(ownerï¼Œ tx_id);\n        tx_id\n    }\n    \n    pub fn confirm_transaction(&mut selfï¼Œ owner: &strï¼Œ tx_id: u32) {\n        let confirmations = self.confirmations.entry(tx_id).or_insert(Vec::new());\n        confirmations.push(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id);\n        }\n    }\n    \n    pub fn execute_transaction(&mut selfï¼Œ tx_id: u32) {\n        if let Some(tx) = self.transactions.get_mut(tx_id as usize) {\n            tx.executed = true;\n            // Execute transfer logic\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_race_conditions", "points": 1, "keywords": ["race", "atomic", "state", "consistency"]}, {"criterion": "implements_atomic_operations", "points": 4, "check_function": "check_atomic_operations"}, {"criterion": "prevents_double_execution", "points": 2, "check_function": "validate_execution_safety"}], "automated_tests": ["test_double_confirmation", "test_execution_atomicity", "test_state_consistency"], "reference_solution": "use std::collections::{HashMapï¼Œ HashSet};\n\n#[derive(Debug)]\npub enum WalletError {\n    UnauthorizedOwnerï¼Œ\n    TransactionNotFoundï¼Œ\n    AlreadyConfirmedï¼Œ\n    AlreadyExecutedï¼Œ\n    InsufficientConfirmationsï¼Œ\n}\n\npub struct MultiSigWallet {\n    owners: HashSet<String>ï¼Œ\n    required_confirmations: u32ï¼Œ\n    transactions: Vec<Transaction>ï¼Œ\n    confirmations: HashMap<u32ï¼Œ HashSet<String>>ï¼Œ\n}\n\npub struct Transaction {\n    id: u32ï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n    executed: boolï¼Œ\n}\n\nimpl MultiSigWallet {\n    pub fn submit_transaction(&mut selfï¼Œ owner: &strï¼Œ to: Stringï¼Œ amount: u64) -> Result<u32ï¼Œ WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx_id = self.transactions.len() as u32;\n        let tx = Transaction {\n            id: tx_idï¼Œ\n            toï¼Œ\n            amountï¼Œ\n            executed: falseï¼Œ\n        };\n        self.transactions.push(tx);\n        self.confirm_transaction(ownerï¼Œ tx_id)?;\n        Ok(tx_id)\n    }\n    \n    pub fn confirm_transaction(&mut selfï¼Œ owner: &strï¼Œ tx_id: u32) -> Result<()ï¼Œ WalletError> {\n        if !self.owners.contains(owner) {\n            return Err(WalletError::UnauthorizedOwner);\n        }\n        \n        let tx = self.transactions.get(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.entry(tx_id).or_insert(HashSet::new());\n        if confirmations.contains(owner) {\n            return Err(WalletError::AlreadyConfirmed);\n        }\n        \n        confirmations.insert(owner.to_string());\n        \n        if confirmations.len() >= self.required_confirmations as usize {\n            self.execute_transaction(tx_id)?;\n        }\n        \n        Ok(())\n    }\n    \n    fn execute_transaction(&mut selfï¼Œ tx_id: u32) -> Result<()ï¼Œ WalletError> {\n        let tx = self.transactions.get_mut(tx_id as usize).ok_or(WalletError::TransactionNotFound)?;\n        if tx.executed {\n            return Err(WalletError::AlreadyExecuted);\n        }\n        \n        let confirmations = self.confirmations.get(&tx_id).unwrap_or(&HashSet::new());\n        if confirmations.len() < self.required_confirmations as usize {\n            return Err(WalletError::InsufficientConfirmations);\n        }\n        \n        tx.executed = true;\n        Ok(())\n    }\n}", "id": 37}
{"question_type": "code_audit", "instructions": "Identify the ownership and borrowing issues in this token transfer contract and provide corrected code that properly handles ownership semantics", "contract_code": "struct Token {\n    owner: Stringï¼Œ\n    balance: u64ï¼Œ\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>ï¼Œ\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&selfï¼Œ from_idx: usizeï¼Œ to_owner: String) -> Result<Tokenï¼Œ &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        transferred_token.balance = token.balance;\n        self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_immutable_borrow_issue", "points": 3, "keywords": ["mutable", "immutable", "borrow", "self"]}, {"criterion": "fixes_ownership_semantics", "points": 2, "check_function": "check_ownership_correction"}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_rust_code"}], "automated_tests": ["test_token_transfer", "test_ownership_transfer"], "reference_solution": "struct Token {\n    owner: Stringï¼Œ\n    balance: u64ï¼Œ\n}\n\nstruct TokenRegistry {\n    tokens: Vec<Token>ï¼Œ\n}\n\nimpl TokenRegistry {\n    fn transfer_token(&mut selfï¼Œ from_idx: usizeï¼Œ to_owner: String) -> Result<Tokenï¼Œ &'static str> {\n        let token = &self.tokens[from_idx];\n        if token.balance == 0 {\n            return Err(\"Insufficient balance\");\n        }\n        let mut transferred_token = token.clone();\n        transferred_token.owner = to_owner;\n        let removed_token = self.tokens.remove(from_idx);\n        Ok(transferred_token)\n    }\n}", "id": 38}
{"question_type": "short_answer", "instructions": "Analyze the lifetime and borrowing issues in this smart contract state management pattern and redesign it to properly handle references and ownership", "contract_code": "struct Account {\n    id: u32ï¼Œ\n    balance: u64ï¼Œ\n    active: boolï¼Œ\n}\n\nstruct ContractState {\n    accounts: Vec<Account>ï¼Œ\n}\n\nimpl ContractState {\n    fn get_account_ref(&selfï¼Œ id: u32) -> Option<&Account> {\n        self.accounts.iter().find(|acc| acc.id == id)\n    }\n    \n    fn update_balance(&mut selfï¼Œ id: u32ï¼Œ new_balance: u64) -> Result<&Accountï¼Œ &'static str> {\n        let account_ref = self.get_account_ref(id);\n        if let Some(account) = account_ref {\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            let account_mut = self.accounts.iter_mut().find(|acc| acc.id == id).unwrap();\n            account_mut.balance = new_balance;\n            Ok(account_mut)\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "vulnerability_type": "ownership", "scoring_criteria": [{"criterion": "identifies_borrow_checker_conflict", "points": 2, "keywords": ["borrow checker", "multiple borrows", "lifetime"]}, {"criterion": "resolves_reference_lifetime_issue", "points": 4, "check_function": "check_lifetime_resolution"}, {"criterion": "code_compiles_and_functions", "points": 1, "check_function": "validate_rust_code"}], "automated_tests": ["test_account_update", "test_borrow_safety"], "reference_solution": "struct Account {\n    id: u32ï¼Œ\n    balance: u64ï¼Œ\n    active: boolï¼Œ\n}\n\nstruct ContractState {\n    accounts: Vec<Account>ï¼Œ\n}\n\nimpl ContractState {\n    fn update_balance(&mut selfï¼Œ id: u32ï¼Œ new_balance: u64) -> Result<&Accountï¼Œ &'static str> {\n        let account_idx = self.accounts.iter().position(|acc| acc.id == id);\n        if let Some(idx) = account_idx {\n            let account = &mut self.accounts[idx];\n            if !account.active {\n                return Err(\"Account inactive\");\n            }\n            account.balance = new_balance;\n            Ok(&self.accounts[idx])\n        } else {\n            Err(\"Account not found\")\n        }\n    }\n}", "id": 39}
{"question_type": "short_answer", "instructions": "Analyze the following smart contract and refactor it to implement proper trait-based modular architecture for different token types. The current implementation violates the single responsibility principle and lacks extensibility.", "contract_code": "pub struct TokenContract {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    token_type: Stringï¼Œ\n    metadata: Stringï¼Œ\n}\n\nimpl TokenContract {\n    pub fn new(token_type: String) -> Self {\n        TokenContract {\n            balances: std::collections::HashMap::new()ï¼Œ\n            token_typeï¼Œ\n            metadata: String::new()ï¼Œ\n        }\n    }\n\n    pub fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        if self.token_type == \"fungible\" {\n            let balance = self.balances.get(from).unwrap_or(&0);\n            if *balance < amount {\n                return Err(\"Insufficient balance\".to_string());\n            }\n            self.balances.insert(from.to_string()ï¼Œ balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        } else if self.token_type == \"nft\" {\n            if amount != 1 {\n                return Err(\"NFT transfer must be exactly 1\".to_string());\n            }\n            // NFT-specific logic here\n        }\n        Ok(())\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "implements_trait_abstraction", "points": 3, "keywords": ["trait", "impl", "abstraction", "interface"]}, {"criterion": "separates_token_behaviors", "points": 2, "keywords": ["modular", "separate", "responsibility", "module"]}, {"criterion": "maintains_functionality", "points": 2, "check_function": "validate_token_functionality"}, {"criterion": "follows_rust_patterns", "points": 1, "keywords": ["enum", "match", "pattern"]}], "automated_tests": ["test_fungible_transfer", "test_nft_transfer", "test_trait_implementation"], "reference_solution": "pub trait TokenBehavior {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn balance_of(&selfï¼Œ account: &str) -> u64;\n}\n\npub struct FungibleToken {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n}\n\npub struct NFTToken {\n    owners: std::collections::HashMap<u64ï¼Œ String>ï¼Œ\n}\n\nimpl TokenBehavior for FungibleToken {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        if *balance < amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        self.balances.insert(from.to_string()ï¼Œ balance - amount);\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n    fn balance_of(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct TokenContract<T: TokenBehavior> {\n    token: Tï¼Œ\n    metadata: Stringï¼Œ\n}\n\nimpl<T: TokenBehavior> TokenContract<T> {\n    pub fn new(token: T) -> Self {\n        TokenContract {\n            tokenï¼Œ\n            metadata: String::new()ï¼Œ\n        }\n    }\n    pub fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        self.token.transfer(fromï¼Œ toï¼Œ amount)\n    }\n}", "id": 40}
{"question_type": "code_audit", "instructions": "Identify the architectural flaw in this multi-contract system and refactor it to implement proper dependency injection and loose coupling between components.", "contract_code": "use std::collections::HashMap;\n\npub struct UserRegistry {\n    users: HashMap<Stringï¼Œ User>ï¼Œ\n}\n\npub struct User {\n    id: Stringï¼Œ\n    balance: u64ï¼Œ\n    reputation: u32ï¼Œ\n}\n\npub struct PaymentProcessor {\n    registry: UserRegistryï¼Œ\n}\n\npub struct ReputationSystem {\n    registry: UserRegistryï¼Œ\n}\n\nimpl PaymentProcessor {\n    pub fn new() -> Self {\n        PaymentProcessor {\n            registry: UserRegistry {\n                users: HashMap::new()ï¼Œ\n            }ï¼Œ\n        }\n    }\n\n    pub fn process_payment(&mut selfï¼Œ user_id: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new() -> Self {\n        ReputationSystem {\n            registry: UserRegistry {\n                users: HashMap::new()ï¼Œ\n            }ï¼Œ\n        }\n    }\n\n    pub fn update_reputation(&mut selfï¼Œ user_id: &strï¼Œ points: u32) -> Result<()ï¼Œ String> {\n        if let Some(user) = self.registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_tight_coupling", "points": 2, "keywords": ["coupling", "dependency", "shared", "independent"]}, {"criterion": "implements_dependency_injection", "points": 4, "keywords": ["injection", "reference", "Arc", "Rc", "shared_state"]}, {"criterion": "maintains_data_consistency", "points": 1, "check_function": "validate_shared_state_access"}], "automated_tests": ["test_shared_user_registry", "test_concurrent_access", "test_dependency_injection"], "reference_solution": "use std::collections::HashMap;\nuse std::rc::Rc;\nuse std::cell::RefCell;\n\npub struct UserRegistry {\n    users: HashMap<Stringï¼Œ User>ï¼Œ\n}\n\npub struct User {\n    id: Stringï¼Œ\n    balance: u64ï¼Œ\n    reputation: u32ï¼Œ\n}\n\ntype SharedRegistry = Rc<RefCell<UserRegistry>>;\n\npub struct PaymentProcessor {\n    registry: SharedRegistryï¼Œ\n}\n\npub struct ReputationSystem {\n    registry: SharedRegistryï¼Œ\n}\n\nimpl PaymentProcessor {\n    pub fn new(registry: SharedRegistry) -> Self {\n        PaymentProcessor { registry }\n    }\n\n    pub fn process_payment(&selfï¼Œ user_id: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            if user.balance >= amount {\n                user.balance -= amount;\n                Ok(())\n            } else {\n                Err(\"Insufficient funds\".to_string())\n            }\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\nimpl ReputationSystem {\n    pub fn new(registry: SharedRegistry) -> Self {\n        ReputationSystem { registry }\n    }\n\n    pub fn update_reputation(&selfï¼Œ user_id: &strï¼Œ points: u32) -> Result<()ï¼Œ String> {\n        let mut registry = self.registry.borrow_mut();\n        if let Some(user) = registry.users.get_mut(user_id) {\n            user.reputation += points;\n            Ok(())\n        } else {\n            Err(\"User not found\".to_string())\n        }\n    }\n}\n\npub fn create_system() -> (PaymentProcessorï¼Œ ReputationSystem) {\n    let registry = Rc::new(RefCell::new(UserRegistry {\n        users: HashMap::new()ï¼Œ\n    }));\n    \n    let payment_processor = PaymentProcessor::new(registry.clone());\n    let reputation_system = ReputationSystem::new(registry.clone());\n    \n    (payment_processorï¼Œ reputation_system)\n}", "id": 41}
{"question_type": "short_answer", "instructions": "Optimize this token transfer contract to reduce memory allocations and improve gas efficiency. Focus on minimizing heap allocations and unnecessary data copies.", "contract_code": "use std::collections::HashMap;\nuse std::string::String;\n\nstruct TokenContract {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfï¼Œ from: Stringï¼Œ to: Stringï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let from_balance = self.balances.get(&from).unwrap_or(&0).clone();\n        let to_balance = self.balances.get(&to).unwrap_or(&0).clone();\n        \n        if from_balance < amount {\n            return Err(format!(\"Insufficient balance: {} < {}\"ï¼Œ from_balanceï¼Œ amount));\n        }\n        \n        self.balances.insert(from.clone()ï¼Œ from_balance - amount);\n        self.balances.insert(to.clone()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n}", "vulnerability_type": "memory_safety", "scoring_criteria": [{"criterion": "eliminates_unnecessary_clones", "points": 3, "keywords": ["clone", "reference", "borrow"]}, {"criterion": "optimizes_string_usage", "points": 2, "keywords": ["&str", "string_slice", "reference"]}, {"criterion": "reduces_heap_allocations", "points": 2, "keywords": ["heap", "allocation", "stack"]}, {"criterion": "maintains_functionality", "points": 1, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_transfer_short_answer", "test_memory_efficiency"], "reference_solution": "use std::collections::HashMap;\n\nstruct TokenContract {\n    balances: HashMap<&'static strï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl TokenContract {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ &'static str> {\n        let from_balance = *self.balances.get(from).unwrap_or(&0);\n        let to_balance = *self.balances.get(to).unwrap_or(&0);\n        \n        if from_balance < amount {\n            return Err(\"Insufficient balance\");\n        }\n        \n        self.balances.insert(fromï¼Œ from_balance - amount);\n        self.balances.insert(toï¼Œ to_balance + amount);\n        Ok(())\n    }\n}", "id": 42}
{"question_type": "code_audit", "instructions": "Analyze the provided staking contract code to identify performance bottlenecks and resource management issues. Optimize the code to support batch operationsï¼Œ integrate yield farming mechanicsï¼Œ and implement slashing penalties for early withdrawals. Ensure the contract can handle high transaction volumes without resource exhaustion.", "factors_to_consider": ["Efficiency of reward calculation", "Integration of yield farming mechanics", "Implementation of slashing penalties", "Scalability for high transaction volumes", "Security against resource exhaustion"], "keywords": ["yield farming", "slashing", "batch operations", "resource management", "DeFi", "scalability"], "expected_insights": ["Identification of nested loop inefficiencies in reward calculation", "Strategies for caching or precomputing rewards to enhance performance", "Approaches to integrate yield farming and slashing mechanisms", "Methods to ensure scalability and prevent resource exhaustion"], "scoring_criteria": [{"criterion": "Identifies and optimizes nested loop inefficiencies", "points": 4, "key_points": ["Recognizes O(n^2) complexity", "Implements caching or precomputation"]}, {"criterion": "Integrates yield farming mechanics", "points": 3, "key_points": ["Implements yield farming logic", "Ensures fair reward distribution"]}, {"criterion": "Implements slashing penalties", "points": 2, "key_points": ["Correctly applies penalties", "Prevents early withdrawal abuse"]}, {"criterion": "Ensures scalability and prevents resource exhaustion", "points": 2, "key_points": ["Handles large transaction volumes", "Implements resource limits"]}], "total_possible": 11, "id": 43, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// This contract is vulnerable to performance issues with a large number of stakers.\n// The reward calculation is inefficient and can lead to out-of-gas errors.\ncontract VulnerableStaking {\n    mapping(address => uint256) public stakes;\n    mapping(address => uint256) public rewards;\n    address[] public stakers;\n\n    function stake() external payable {\n        require(msg.value > 0ï¼Œ \"Cannot stake 0\");\n        if (stakes[msg.sender] == 0) {\n            stakers.push(msg.sender);\n        }\n        stakes[msg.sender] += msg.value;\n    }\n\n    // This function is very inefficient and will consume a lot of gas with many stakers.\n    function distributeRewards() external {\n        for (uint256 i = 0; i < stakers.length; i++) {\n            address staker = stakers[i];\n            rewards[staker] += calculateReward(staker);\n        }\n    }\n\n    // A simple reward calculation function.\n    function calculateReward(address staker) internal view returns (uint256) {\n        return stakes[staker] / 100;\n    }\n\n    function withdraw() external {\n        uint256 amount = stakes[msg.sender];\n        require(amount > 0ï¼Œ \"No stake to withdraw\");\n        stakes[msg.sender] = 0;\n        payable(msg.sender).transfer(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "This smart contract has a critical bug in the withdrawal logic that only manifests under specific conditions. Write comprehensive unit tests that would catch this bugï¼Œ identify the issueï¼Œ and provide a corrected implementation with proper error handling.", "contract_code": "use std::collections::HashMap;\n\n#[derive(Debug)]\nstruct TokenVault {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl TokenVault {\n    fn new() -> Self {\n        TokenVault {\n            balances: HashMap::new()ï¼Œ\n            total_supply: 0ï¼Œ\n        }\n    }\n    \n    fn deposit(&mut selfï¼Œ user: Stringï¼Œ amount: u64) {\n        let balance = self.balances.entry(user).or_insert(0);\n        *balance += amount;\n        self.total_supply += amount;\n    }\n    \n    fn withdraw(&mut selfï¼Œ user: Stringï¼Œ amount: u64) -> bool {\n        if let Some(balance) = self.balances.get_mut(&user) {\n            if *balance >= amount {\n                *balance -= amount;\n                self.total_supply -= amount;\n                return true;\n            }\n        }\n        false\n    }\n    \n    fn get_balance(&selfï¼Œ user: &str) -> u64 {\n        self.balances.get(user).copied().unwrap_or(0)\n    }\n}", "vulnerability_type": "state_management", "scoring_criteria": [{"criterion": "identifies_state_inconsistency", "points": 3, "keywords": ["state", "inconsistent", "total_supply", "balance"]}, {"criterion": "writes_comprehensive_tests", "points": 2, "keywords": ["test", "assert", "edge_case"]}, {"criterion": "implements_proper_error_handling", "points": 3, "check_function": "check_error_handling_implementation"}, {"criterion": "validates_state_invariants", "points": 2, "keywords": ["invariant", "consistency", "validation"]}], "automated_tests": ["test_state_consistency", "test_edge_cases"], "reference_solution": "// Tests should reveal that total_supply can become inconsistent\n// Bug: No validation that total_supply calculation remains correct\n// Fix: Add state validation and proper error types", "id": 44}
{"question_type": "code_audit", "instructions": "Analyze this multi-signature wallet implementation for debugging and testing issues. The contract has subtle bugs that would cause failures in production. Identify the ownership and concurrency issuesï¼Œ then provide a corrected version with proper debug tooling and testing infrastructure.", "contract_code": "use std::sync::{Arcï¼Œ Mutex};\nuse std::thread;\n\n#[derive(Debugï¼Œ Clone)]\nstruct MultiSigWallet {\n    owners: Vec<String>ï¼Œ\n    required_signatures: usizeï¼Œ\n    pending_transactions: Arc<Mutex<Vec<Transaction>>>ï¼Œ\n}\n\n#[derive(Debugï¼Œ Clone)]\nstruct Transaction {\n    id: u64ï¼Œ\n    to: Stringï¼Œ\n    amount: u64ï¼Œ\n    signatures: Vec<String>ï¼Œ\n    executed: boolï¼Œ\n}\n\nimpl MultiSigWallet {\n    fn new(owners: Vec<String>ï¼Œ required_sigs: usize) -> Self {\n        MultiSigWallet {\n            ownersï¼Œ\n            required_signatures: required_sigsï¼Œ\n            pending_transactions: Arc::new(Mutex::new(Vec::new()))ï¼Œ\n        }\n    }\n    \n    fn sign_transaction(&selfï¼Œ tx_id: u64ï¼Œ signer: String) -> bool {\n        let mut transactions = self.pending_transactions.lock().unwrap();\n        for tx in transactions.iter_mut() {\n            if tx.id == tx_id && !tx.executed {\n                tx.signatures.push(signer);\n                if tx.signatures.len() >= self.required_signatures {\n                    tx.executed = true;\n                    return true;\n                }\n            }\n        }\n        false\n    }\n}", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_debugging_issues", "points": 2, "keywords": ["debug", "logging", "error_handling", "mutex"]}, {"criterion": "fixes_concurrency_bugs", "points": 4, "keywords": ["concurrency", "race_condition", "lock", "thread_safety"]}, {"criterion": "implements_testing_framework", "points": 1, "check_function": "validate_test_infrastructure"}, {"criterion": "adds_proper_validation", "points": 3, "keywords": ["validation", "duplicate", "owner_check"]}], "automated_tests": ["test_concurrent_signing", "test_duplicate_signatures"], "reference_solution": "// Issues: No duplicate signature preventionï¼Œ no owner validationï¼Œ poor error handling\n// Fix: Add owner validationï¼Œ prevent duplicate signaturesï¼Œ implement proper Result types", "id": 45}
{"question_type": "code_audit", "instructions": "Examine the provided smart contract code for vulnerabilities related to interface exposure and unauthorized access. Propose a secure implementation that restricts access to the vault contractï¼Œ ensuring only authorized transactions are processed. Your solution should maintain the integrity of the interface design and adhere to best practices in Web3 security.", "factors_to_consider": ["Access control mechanisms", "Interface encapsulation", "Authorization checks", "Compliance with Web3 security standards"], "keywords": ["access control", "interface encapsulation", "authorization", "Web3 security", "smart contract audit"], "expected_insights": ["Identification of direct interface exposure risks", "Implementation of robust access control measures", "Understanding of Web3-specific security practices", "Ability to maintain interface integrity while enhancing security"], "scoring_criteria": [{"criterion": "Identifies interface exposure", "points": 3, "key_points": ["Recognizes direct access to the vault", "Understands risks of interface exposure"]}, {"criterion": "Implements proper access control", "points": 4, "key_points": ["Applies authorization checks", "Prevents unauthorized transactions"]}, {"criterion": "Maintains interface design", "points": 2, "key_points": ["Preserves original interface structure", "Ensures compatibility with existing contracts"]}, {"criterion": "Adheres to Web3 security standards", "points": 3, "key_points": ["Follows best practices in smart contract security", "Demonstrates understanding of decentralized systems"]}], "total_possible": 12, "id": 46, "contract_code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.22;\n\n// An interface for a simple vault.\ninterface IVault {\n    function withdraw(uint256 amount) external;\n}\n\n// A vault contract that is vulnerable to unauthorized access.\n// The owner of the vault is not properly checked.\ncontract VulnerableVault is IVault {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    function withdraw(uint256 amount) external override {\n        // This check is insufficient because it does not verify the caller.\n        require(address(this).balance >= amountï¼Œ \"Insufficient balance\");\n        payable(msg.sender).transfer(amount);\n    }\n\n    receive() external payable {}\n}\n\n// A contract that interacts with the vault.\n// It exposes the vault interface directlyï¼Œ allowing anyone to call it.\ncontract VaultInteractor {\n    IVault public vault;\n\n    constructor(address _vaultAddress) {\n        vault = IVault(_vaultAddress);\n    }\n\n    // This function allows anyone to withdraw from the vault.\n    function doWithdraw(uint256 amount) public {\n        vault.withdraw(amount);\n    }\n}\n"}
{"question_type": "short_answer", "instructions": "Refactor this cross-contract communication system to implement proper error handling and eliminate panic conditions while maintaining interface compatibility across contract boundaries", "contract_code": "pub trait TokenInterface {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn mint(&mut selfï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn burn(&mut selfï¼Œ from: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn balance_of(&selfï¼Œ account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let from_balance = self.balances.get(from).ok_or_else(|| \"Source account not found\".to_string())?;\n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        let to_balance = self.balances.get(to).unwrap_or(&0);\n\n        self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n\n    fn mint(&mut selfï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(to.to_string()ï¼Œ balance + amount);\n        self.total_supply += amount;\n        Ok(())\n    }\n\n    fn burn(&mut selfï¼Œ from: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let balance = self.balances.get(from).ok_or_else(|| \"Account not found\".to_string())?;\n        if balance < &amount {\n            return Err(\"Insufficient funds to burn\".to_string());\n        }\n        self.balances.insert(from.to_string()ï¼Œ balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n\n    fn balance_of(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n", "vulnerability_type": "error_handling", "scoring_criteria": [{"criterion": "identifies_panic_conditions", "points": 2, "keywords": ["panic", "unwrap", "assert", "error handling"]}, {"criterion": "implements_result_based_interface", "points": 2, "check_function": "check_result_type_usage"}, {"criterion": "maintains_interface_compatibility", "points": 3, "check_function": "validate_interface_compatibility"}], "automated_tests": ["test_error_propagation", "test_interface_compatibility"], "reference_solution": "pub trait TokenInterface {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn mint(&mut selfï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn burn(&mut selfï¼Œ from: &strï¼Œ amount: u64) -> Result<()ï¼Œ String>;\n    fn balance_of(&selfï¼Œ account: &str) -> u64;\n}\n\npub struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl TokenInterface for Token {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        \n        if from_balance < &amount {\n            return Err(\"Insufficient balance\".to_string());\n        }\n        \n        let to_balance = self.balances.get(to).unwrap_or(&0);\n        self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n        self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n        Ok(())\n    }\n    \n    fn mint(&mut selfï¼Œ to: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let balance = self.balances.get(to).unwrap_or(&0);\n        \n        if let Some(new_balance) = balance.checked_add(amount) {\n            self.balances.insert(to.to_string()ï¼Œ new_balance);\n            self.total_supply = self.total_supply.checked_add(amount)\n                .ok_or(\"Total supply overflow\")?;\n            Ok(())\n        } else {\n            Err(\"Balance overflow\".to_string())\n        }\n    }\n    \n    fn burn(&mut selfï¼Œ from: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        let balance = self.balances.get(from).unwrap_or(&0);\n        \n        if balance < &amount {\n            return Err(\"Insufficient balance to burn\".to_string());\n        }\n        \n        self.balances.insert(from.to_string()ï¼Œ balance - amount);\n        self.total_supply -= amount;\n        Ok(())\n    }\n    \n    fn balance_of(&selfï¼Œ account: &str) -> u64 {\n        *self.balances.get(account).unwrap_or(&0)\n    }\n}\n\npub struct DeFiProtocol {\n    token: Tokenï¼Œ\n}\n\nimpl DeFiProtocol {\n    pub fn swap_tokens(&mut selfï¼Œ user: &strï¼Œ amount: u64) -> Result<()ï¼Œ String> {\n        self.token.burn(userï¼Œ amount)?;\n        self.token.mint(userï¼Œ amount * 2)?;\n        Ok(())\n    }\n}", "id": 47}
{"question_type": "code_audit", "instructions": "Identify the integer overflow vulnerability in this token transfer function and provide a secure implementation that prevents arithmetic overflow attacks", "contract_code": "struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl Token {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> bool {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            self.balances.insert(to.to_string()ï¼Œ to_balance + amount);\n            return true;\n        }\n        false\n    }\n}", "vulnerability_type": "integer_overflow", "scoring_criteria": [{"criterion": "identifies_overflow_vulnerability", "points": 3, "keywords": ["overflow", "arithmetic", "wrapping", "checked"]}, {"criterion": "implements_safe_arithmetic", "points": 4, "check_function": "check_safe_arithmetic_operations"}, {"criterion": "maintains_contract_functionality", "points": 2, "check_function": "validate_transfer_logic"}], "automated_tests": ["test_overflow_prevention", "test_normal_transfer"], "reference_solution": "struct Token {\n    balances: std::collections::HashMap<Stringï¼Œ u64>ï¼Œ\n    total_supply: u64ï¼Œ\n}\n\nimpl Token {\n    fn transfer(&mut selfï¼Œ from: &strï¼Œ to: &strï¼Œ amount: u64) -> Result<boolï¼Œ &'static str> {\n        let from_balance = self.balances.get(from).unwrap_or(&0);\n        if *from_balance >= amount {\n            self.balances.insert(from.to_string()ï¼Œ from_balance - amount);\n            let to_balance = self.balances.get(to).unwrap_or(&0);\n            match to_balance.checked_add(amount) {\n                Some(new_balance) => {\n                    self.balances.insert(to.to_string()ï¼Œ new_balance);\n                    Ok(true)\n                }\n                None => Err(\"Arithmetic overflow prevented\")\n            }\n        } else {\n            Ok(false)\n        }\n    }\n}", "id": 48}
{"question_type": "code_audit", "instructions": "Analyze this smart contract for reentrancy vulnerabilities and implement proper state management to prevent reentrancy attacks", "contract_code": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_deposits: u64ï¼Œ\n}\n\nimpl Vault {\n    fn withdraw(&mut selfï¼Œ user: &strï¼Œ amount: u64) -> Result<()ï¼Œ &'static str> {\n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // External call simulation\n            self.external_transfer(userï¼Œ amount)?;\n            \n            // State update after external call\n            self.balances.insert(user.to_string()ï¼Œ balance - amount);\n            self.total_deposits -= amount;\n            Ok(())\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&selfï¼Œ _user: &strï¼Œ _amount: u64) -> Result<()ï¼Œ &'static str> {\n        // Simulates external contract call\n        Ok(())\n    }\n}", "vulnerability_type": "reentrancy", "scoring_criteria": [{"criterion": "identifies_reentrancy_pattern", "points": 2, "keywords": ["reentrancy", "state", "external", "call"]}, {"criterion": "implements_checks_effects_interactions", "points": 2, "check_function": "check_state_update_order"}, {"criterion": "adds_reentrancy_guard", "points": 3, "check_function": "validate_reentrancy_protection"}], "automated_tests": ["test_reentrancy_prevention", "test_state_consistency"], "reference_solution": "use std::collections::HashMap;\n\nstruct Vault {\n    balances: HashMap<Stringï¼Œ u64>ï¼Œ\n    total_deposits: u64ï¼Œ\n    locked: boolï¼Œ\n}\n\nimpl Vault {\n    fn withdraw(&mut selfï¼Œ user: &strï¼Œ amount: u64) -> Result<()ï¼Œ &'static str> {\n        if self.locked {\n            return Err(\"Reentrant call detected\");\n        }\n        \n        let balance = self.balances.get(user).unwrap_or(&0);\n        if *balance >= amount {\n            // Update state before external call\n            self.balances.insert(user.to_string()ï¼Œ balance - amount);\n            self.total_deposits -= amount;\n            \n            // Set reentrancy guard\n            self.locked = true;\n            let result = self.external_transfer(userï¼Œ amount);\n            self.locked = false;\n            \n            result\n        } else {\n            Err(\"Insufficient balance\")\n        }\n    }\n    \n    fn external_transfer(&selfï¼Œ _user: &strï¼Œ _amount: u64) -> Result<()ï¼Œ &'static str> {\n        Ok(())\n    }\n}", "id": 49}
