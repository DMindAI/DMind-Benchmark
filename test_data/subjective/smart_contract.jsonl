{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contract_code":"contract VulnerableBank {\n    mapping(address => uint) public balances;\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value： _amount}(\"\"); \n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= _amount; \n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant","重入"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_external_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_guard"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_deposit_withdraw_workflow","test_reentrancy_attack_prevention"],"reference_solution":"contract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    modifier noReentrant() {\n        require(!locked, \"Reentrant call detected\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{value： _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contracts":[{"language":"Solidity","contract_code":"// Solidity 0.8.x\ncontract VulnerableBank {\n    mapping(address => uint) public balances;\n    \n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() external {\n        uint amount = balances[msg.sender];\n        require(address(this).balance >= amount, 'Insufficient funds');\n        (bool success, ) = msg.sender.call{value： amount}('');\n        require(success);\n        balances[msg.sender] = 0;\n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_lock"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_reentrancy_attack_prevention"],"reference_solution":"// Solidity 0.8.x\ncontract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    \n    modifier noReentrant() {\n        require(!locked, 'Reentrancy detected');\n        locked = true;\n        _;\n        locked = false;\n    }\n    \n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() external noReentrant {\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n        (bool success, ) = msg.sender.call{value： amount}('');\n        require(success);\n    }\n}"},{"language":"Move","contract_code":"// Move\nmodule MyToken {\n    struct Coin has key {}\n    \n    public entry transfer(sender： &signer， receiver： address， amount： u64) {\n        let coin： Coin<amount> = move_from<@Coin>(sender);\n        move_to<@Coin>(receiver， Coin { value： amount });\n    }\n}","vulnerability_type":"resource_leak","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["resource leak","资源泄漏"]},{"criterion":"correct_resource_management","points":3,"check_function":"check_resource_transfer"},{"criterion":"code_compiles","points":1,"check_function":"validate_move_code"}],"automated_tests":["test_resource_integrity"],"reference_solution":"// Move\nmodule MyToken {\n    struct Coin has key { value： u64 }\n    \n    public entry transfer(sender： &signer， receiver： address， amount： u64) {\n        let coin： Coin<amount> = move_from<@Coin>(sender);\n        move_to<@Coin>(receiver， Coin { value： amount });\n        // Correctly destroy the original coin\n        destroy<@Coin>(coin);\n    }\n}"},{"language":"Go","contract_code":"// Go\npackage main\nimport \"fmt\"\n\nvar balance = make(map[string]int)\n\nfunc Deposit(addr string， amount int) {\n    balance[addr] += amount\n}\n\nfunc Withdraw(addr string) {\n    amount := balance[addr]\n    fmt.Printf(\"Withdrawing %d\\n\"， amount)\n    balance[addr] = 0\n}\n\nfunc main() {\n    go Deposit(\"alice\", 100)\n    Withdraw(\"alice\")\n    Deposit(\"alice\", 50)\n    fmt.Println(balance[\"alice\"]) // Expected 50 but may get 0\n}","vulnerability_type":"race_condition","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["race condition","竞态条件"]},{"criterion":"implements_mutex","points":3,"check_function":"check_mutex_usage"},{"criterion":"code_compiles","points":1,"check_function":"validate_go_code"}],"automated_tests":["test_concurrency_safety"],"reference_solution":"// Go\npackage main\nimport (\"fmt\"; \"sync\")\n\nvar balance = make(map[string]int)\nvar mu sync.Mutex\n\nfunc Deposit(addr string， amount int) {\n    mu.Lock()\n    defer mu.Unlock()\n    balance[addr] += amount\n}\n\nfunc Withdraw(addr string) {\n    mu.Lock()\n    defer mu.Unlock()\n    amount := balance[addr]\n    fmt.Printf(\"Withdrawing %d\\n\"， amount)\n    balance[addr] = 0\n}\n"},{"language":"Solidity","contract_code":"// Solidity 0.8.x\ncontract VulnerableToken {\n    mapping(address => uint) public balances;\n    \n    function transfer(address _to， uint _value) external {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n    }\n}","vulnerability_type":"integer_overflow","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["integer overflow"]},{"criterion":"uses_safe_math","points":3,"check_function":"check_safe_math"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_overflow_prevention"],"reference_solution":"// Solidity 0.8.x\ncontract SafeToken {\n    using SafeMath for uint;\n    mapping(address => uint) public balances;\n    \n    function transfer(address _to， uint _value) external {\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n    }\n}\n// Requires SafeMath library implementation"},{"language":"Rust","contract_code":"// Rust\nstruct Bank {\n    balances： std::collections::HashMap<String， u32>,\n}\n\nimpl Bank {\n    pub fn new() -> Bank {\n        Bank { balances： HashMap::new() }\n    }\n    \n    pub fn deposit(&mut self， addr： &str， amount： u32) {\n        let current = self.balances.get(addr).unwrap_or(&0);\n        self.balances.insert(addr.to_string()， current + amount);\n    }\n    \n    pub fn withdraw(&mut self， addr： &str， amount： u32) {\n        let current = self.balances.get_mut(addr).unwrap();\n        *current -= amount;\n    }\n}","vulnerability_type":"unwrap_panic","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["unwrap","panic"]},{"criterion":"handles_option","points":3,"check_function":"check_option_handling"},{"criterion":"code_compiles","points":1,"check_function":"validate_rust_code"}],"automated_tests":["test_safe_option_handling"],"reference_solution":"// Rust\nuse std::collections::HashMap;\n\nstruct Bank {\n    balances： HashMap<String， u32>,\n}\n\nimpl Bank {\n    pub fn new() -> Bank {\n        Bank { balances： HashMap::new() }\n    }\n    \n    pub fn deposit(&mut self， addr： &str， amount： u32) {\n        *self.balances.entry(addr.to_string()).or_insert(0) += amount;\n    }\n    \n    pub fn withdraw(&mut self， addr： &str， amount： u32) -> Result<()， String> {\n        let entry = self.balances.get_mut(addr);\n        match entry {\n            Some(v) if *v >= amount => {\n                *v -= amount;\n                Ok(())\n            },\n            _ => Err(\"Insufficient funds\".to_string()),\n        }\n    }\n}"}]}
{"question_type":"code_audit","instructions":"Identify the vulnerability in the smart contract and provide fixed code","contract_code":"contract VulnerableBank {\n    mapping(address => uint) public balances;\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        (bool success, ) = msg.sender.call{value： _amount}(\"\"); \n        require(success, \"Transfer failed\");\n        balances[msg.sender] -= _amount; \n    }\n}","vulnerability_type":"reentrancy","scoring_criteria":[{"criterion":"identifies_vulnerability_type","points":2,"keywords":["reentrancy","reentrant","重入"]},{"criterion":"follows_checks_effects_interactions","points":3,"check_function":"check_state_update_before_external_call"},{"criterion":"implements_reentrancy_guard","points":2,"check_function":"check_reentrancy_guard"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_deposit_withdraw_workflow","test_reentrancy_attack_prevention"],"reference_solution":"contract SecureBank {\n    mapping(address => uint) public balances;\n    bool private locked;\n    modifier noReentrant() {\n        require(!locked, \"Reentrant call detected\");\n        locked = true;\n        _;\n        locked = false;\n    }\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n    }\n    function withdraw(uint _amount) external noReentrant {\n        require(balances[msg.sender] >= _amount, \"Insufficient balance\");\n        balances[msg.sender] -= _amount;\n        (bool success, ) = msg.sender.call{value： _amount}(\"\");\n        require(success, \"Transfer failed\");\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the efficiency issue in the smart contract and provide fixed code","contract_code":"contract GasInefficientContract {\n    uint[] public values;\n    function addValue(uint _value) public {\n        values.push(_value);\n    }\n    function getTotalValues() public view returns(uint total) {\n        for (uint i = 0; i < values.length; i++) {\n            total += values[i];\n        }\n    }\n}","vulnerability_type":"gas optimization","scoring_criteria":[{"criterion":"identifies_gas_inefficiency","points":2,"keywords":["gas","optimization","inefficiency"]},{"criterion":"provides_gas_optimized_solution","points":3,"check_function":"check_gas_optimization"},{"criterion":"code_compiles","points":1,"check_function":"validate_solidity_code"}],"automated_tests":["test_add_value","test_get_total_values"],"reference_solution":"contract GasOptimizedContract {\n    uint total;\n    function addValue(uint _value) public {\n        total += _value;\n    }\n    function getTotalValues() public view returns(uint) {\n        return total;\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the issue in the Move contract and provide fixed code","contract_code":"module VulnerableModule {\n    public fun create_account(account： address)： address {\n        let account_balance = 0;\n        return account_balance;\n    }\n}","vulnerability_type":"resource initialization","scoring_criteria":[{"criterion":"identifies_resource_initialization","points":2,"keywords":["resource","initialization"]},{"criterion":"provides_valid_resource_type","points":3,"check_function":"check_resource_type"},{"criterion":"code_compiles","points":1,"check_function":"validate_move_code"}],"automated_tests":["test_create_account"],"reference_solution":"module FixedModule {\n    public fun create_account(account： address)： &mut account_balance {\n        let account_balance = 0;\n        return account_balance;\n    }\n}"}
{"question_type":"code_audit","instructions":"Identify the concurrency issue in the Go code and provide fixed code","contract_code":"package main\nimport \"sync\"\ntype BankAccount struct {\n    balance int\n    mu sync.Mutex\n}\nfunc (a *BankAccount) Deposit(amount int) {\n    a.balance += amount\n}\nfunc (a *BankAccount) Withdraw(amount int) {\n    if a.balance >= amount {\n        a.balance -= amount\n    }\n}","vulnerability_type":"concurrency","scoring_criteria":[{"criterion":"identifies_concurrency_issue","points":2,"keywords":["concurrency","mutex","lock"]},{"criterion":"corrects_concurrency_issue","points":3,"check_function":"check_mutex_lock_usage"},{"criterion":"code_compiles","points":1,"check_function":"validate_go_code"}],"automated_tests":["test_deposit_withdraw"],"reference_solution":"package main\nimport \"sync\"\ntype BankAccount struct {\n    balance int\n    mu sync.Mutex\n}\nfunc (a *BankAccount) Deposit(amount int) {\n    a.mu.Lock()\n    a.balance += amount\n    a.mu.Unlock()\n}\nfunc (a *BankAccount) Withdraw(amount int) {\n    a.mu.Lock()\n    if a.balance >= amount {\n        a.balance -= amount\n    }\n    a.mu.Unlock()\n}"}
{"question_type":"code_audit","instructions":"Identify the ownership issue in the Rust contract and provide fixed code","contract_code":"struct Wallet {\n    balance： u32,\n}\nfn transfer(wallet： &Wallet， amount： u32) {\n    wallet.balance -= amount;\n}","vulnerability_type":"ownership","scoring_criteria":[{"criterion":"identifies_ownership_issue","points":2,"keywords":["ownership","borrowing","reference"]},{"criterion":"corrects_ownership_issue","points":3,"check_function":"check_ownership_correction"},{"criterion":"code_compiles","points":1,"check_function":"validate_rust_code"}],"automated_tests":["test_transfer"],"reference_solution":"struct Wallet {\n    balance： u32,\n}\nfn transfer(wallet： &mut Wallet， amount： u32) {\n    wallet.balance -= amount;\n}"} 